<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Using ATrace(Android system and app trace events)</title>
      <link href="2020/11/12/using_atrace/"/>
      <url>2020/11/12/using_atrace/</url>
      
        <content type="html"><![CDATA[<h2 id="atrace是什么"><a href="#atrace是什么" class="headerlink" title="atrace是什么"></a>atrace是什么</h2><p>atarce(Android system and app trace events)是Android系统和软件的事件追踪器，支持用户空间的系统事件和软件事件，以及内核空间的函数追踪。它支持设置属性来进行用户空间追踪，也可以写入ftrace的sysfs节点进行事件追踪，还能利用function tracer进行内核中大部分函数进行追踪。<br>它一方面通过NDK层设置接口给JNI提供API，另一方面又通过zygote在Android内部进程中对属性及时响应，还在通过设置ftrace下的节点属性控制信息输出。</p><h2 id="atrace流程图"><a href="#atrace流程图" class="headerlink" title="atrace流程图"></a>atrace流程图</h2><p><img src="/images/using_atrace/atrace_2.jpg" alt="atrace_2"></p><h2 id="atrace信息捕获"><a href="#atrace信息捕获" class="headerlink" title="atrace信息捕获"></a>atrace信息捕获</h2><p>根据atrace.cpp源码可以看出，对于追踪类型的分类依据来源于k_categories结构中定义好的值。k_categories是一个TracingCategory结构体，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct TracingCategory &#123;</span><br><span class="line">    &#x2F;&#x2F; The name identifying the category.</span><br><span class="line">    const char* name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; A longer description of the category.</span><br><span class="line">    const char* longname;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The userland tracing tags that the category enables.</span><br><span class="line">    uint64_t tags;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The fname&#x3D;&#x3D;NULL terminated list of &#x2F;sys&#x2F; files that the category</span><br><span class="line">    &#x2F;&#x2F; enables.</span><br><span class="line">    struct &#123;</span><br><span class="line">        &#x2F;&#x2F; Whether the file must be writable in order to enable the tracing</span><br><span class="line">        &#x2F;&#x2F; category.</span><br><span class="line">        requiredness required;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; The path to the enable file.</span><br><span class="line">        const char* path;</span><br><span class="line">    &#125; sysfiles[MAX_SYS_FILES];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中成员tags能够对用户空间的追踪选项进行标识，sysfiles则提供了某个追踪类别的节点信息。atrace使用参数-k来标识是否启用内核函数追踪。根据参数-k和k_categories可以知道，atrace主要采用如下几种方式来进行追踪。</p><h4 id="1-ATRACE-TAG方式"><a href="#1-ATRACE-TAG方式" class="headerlink" title="1. ATRACE_TAG方式"></a>1. ATRACE_TAG方式</h4><p>ATRACE_TAG方式是atrace的默认方式，使能方法是传入默认的追踪类型。它是只针对用户空间的追踪方式，通过将k_categories中各个非零tags的标识位进行按位或运算后来设置系统属性debug.atrace.tags.enableflags。在Android系统中，zygote进程启动后，通过一系列调用判断ATRACE_TAG的设置和ATRACE_CALL()或ATrace_beginSection的位置，以WRITE_MSG的形式写入atrace_marker_fd，即trace_marker的位置，填充ftrace的ring buffer。具体的时序图如下:</p><p><img src="/images/using_atrace/zygote.jpg" alt="zygote"></p><p><img src="/images/using_atrace/getprop.jpg" alt="getprop"></p><p><img src="/images/using_atrace/atrace_call.jpg" alt="atrace_call"></p><p>在NDK层封装好API后，通过JNI的机制，就可以在java里调用trace。在<code>frameworks/base/core/jni/android_os_Trace.cpp</code>中设置如下:</p><p><img src="/images/using_atrace/jniatrace.png" alt="jniatrace"></p><p>对于ATRACE_TAG来说，java层采取和libcutils相同的方式，采用相同的标志位进行声明，确保分类一致。</p><p><img src="/images/using_atrace/tracetag.jpg" alt="tracetag"></p><p>之后就可以在framework层中轻松的使用trace了，例如:</p><p><img src="/images/using_atrace/framework.png" alt="framework"></p><h4 id="2-appname方式"><a href="#2-appname方式" class="headerlink" title="2. appname方式"></a>2. appname方式</h4><p>appname方式能够对设置的进程名称进行追踪，但可能会导致一系列不可控的返回信息。其使能方式是通过参数-a传入包名来进行设置，然后设置系统属性debug.atrace.app_number和debug.atrace.app，确定追踪的包名的个数和对应的属性，之后也是类似ATRACE_TAG的方式使用libcutils进行追踪。具体的时序图如下：</p><p><img src="/images/using_atrace/appname.jpg" alt="appname"></p><p>appname方式会在进程内部读取/proc/self/cmdline的第一行，然后和系统属性debug.atrace.app进行比对，当匹配成功时代表该进程需要进行app级别的调试追踪，然后设置ATRACE_TAG_APP，</p><h4 id="3-trace-event方式"><a href="#3-trace-event方式" class="headerlink" title="3. trace event方式"></a>3. trace event方式</h4><p>trace event方式是对debugfs中events下的节点使能来进行追踪控制的。通常来说，trace event使用宏TRACE_EVENT()来新增追踪事件。当对应节点被使能后，函数插桩被激活，桩点中的函数被调用时就会被记录下来，将数据通过设置好的filter和trigger存储到ring buffer中，最后通过设置好的format进行格式化输出。<br>对于format中每个块来说，filed格式为<code>field:field-type field-name; offset:N; size:N;</code>，如果一个field-name以<code>common_</code>开头的话，说明这个field是公共定义的，在相同的event下都享受这个filed。<br>对于event的filter来说，可以通过多种方式就行过滤。比如可以通过表达式语法来指定某些条件下field-name的匹配；也可以直接控制某个event下的所有子系统，此时会根据具体的filter下是否有修改的field来进行修改；还可以利用PID的方式直接对<code>set_event_pid</code>节点进行设置，<br>trigger则是用来对event的控制命令进行过滤。它可以控制这个另一个event的开启与关闭当这个event的trigger被激活时，也可以转储堆栈追踪、记录捕获的函数到snapshot中，也能直接控制追踪的开启与关闭。值得注意的是，这些trigger commands都能通过表达式语法来进行更细致的控制，能够直接对每个event定义的<code>TP_STRUCT__entry</code>中的成员来用于条件判断。</p><h4 id="4-内核函数追踪方式"><a href="#4-内核函数追踪方式" class="headerlink" title="4. 内核函数追踪方式"></a>4. 内核函数追踪方式</h4><p>内核函数追踪方式能够对内核中大部分函数(不包括notrace、inline、某些特殊函数)进行追踪，其原理是ftrace中的dynamic fucntion tracer。内核函数追踪的使能方式是通过参数-k来设置要追踪哪几个函数。dynamic fucntion tracer有两种方式，一种是function的方式，另一种是function_graph的方式。对于dynamic fucntion tracer来说，它可以把不需要追踪的函数入口处指令<code>bl _mcount</code>替换成<code>nop</code>，这样基本对性能无影响，对需要追踪的函数替换入口处指令<code>bl _mcount</code>替换为<code>ftrace_caller</code>。对于dynamic function_graph tracer来说，则需要对函数的入口和出口同时插桩，获得函数的执行时间。需要注意的是，atrace默认的内核函数采用function_graph的方式进行，而修改后的atrace则可以采用function的方式。</p><h2 id="function与function-graph的性能比较"><a href="#function与function-graph的性能比较" class="headerlink" title="function与function_graph的性能比较"></a>function与function_graph的性能比较</h2><p><img src="/images/using_atrace/compare.png" alt="compare"></p><p>根据实际测试比较可知，在使用function和function_graph两种tracer时候，在其他参数一致的情况下，两种方式的追踪消耗时间实际上是差不多的，而且内存占用也差不多。但是function tracer比function_graph tracer的cpu消耗多了40%，而且与系统追踪相比，内核追踪的cpu消耗极大。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>What We Talk About When We Talk About ChrDev</title>
      <link href="2020/09/17/what_we_talk_about_when_we_talk_about_chrdev/"/>
      <url>2020/09/17/what_we_talk_about_when_we_talk_about_chrdev/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文内核版本主要基于4.14，少部分会与5.8.7版本进行比较。</p></blockquote><h2 id="什么是设备驱动程序"><a href="#什么是设备驱动程序" class="headerlink" title="什么是设备驱动程序"></a>什么是设备驱动程序</h2><p>Linux内核拥有庞大而复杂的代码，通常内核黑客(kernel hacker)需要找到一个进入内核的方法，设备驱动程序就是其中一个选择。设备驱动程序作为应用软件和硬件之间的纽带，软件上层调用API接口，通过中间的设备驱动程序驱使底层硬件设备进行具体工作。设备驱动程序通常不会提供具体的策略，而是处理硬件适用的问题，用以展现设备的特性。</p><h2 id="设备驱动包括哪些"><a href="#设备驱动包括哪些" class="headerlink" title="设备驱动包括哪些"></a>设备驱动包括哪些</h2><p>作为不太严格的划分，Linux系统设备通常分为三类：字符设备、块设备和网络设备。字符设备和块设备的区别在于内核传递数据的方式不一致，两者都是通过文件系统节点来访问。当然，Linux还有其他类型的设备用以实现其他的任务，但总的来看，内核可以通过动态的加载内核模块实现具体的功能。</p><p>使用<code>ll /dev</code>查看设备文件的具体信息：</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200917112623.png"></p><p>可以看到，文件属性字段的第一个字母直接表明了该设备的种类，字母c代表字符设备文件，字母b代表块设备文件。同时，原本标识文件长度的地方现在变为了两个编号，这是因为Linux内核采用主设备号和次设备号标识一个确定的设备驱动程序。一个驱动程序可以分配多个主设备号，同一个设备驱动程序可以管理多个同样类型的设备，通过次设备号来标识。</p><p>下文主要讨论字符设备。</p><h2 id="上层应用与底层驱动"><a href="#上层应用与底层驱动" class="headerlink" title="上层应用与底层驱动"></a>上层应用与底层驱动</h2><p>在Linux中，由于“一切皆文件”的性质，对于硬件设备的操作在应用中就被视作了文件的操作，每个文件被一个struct inode结构体来描述，而对于字符设备驱动的inode来说，其中包含一个struct cdev结构体记录字符设备。当open函数打开设备文件时，根据inode结构中的设备信息可以判断该设备文件是字符设备还是块设备并分配一个struct file，之后根据inode中dev_t类型的设备号找到对应的驱动程序。同时将struct cdev的内存空间首地址存储到inode中的i_cdev成员中，将struct cdev的接口函数操作地址存储到file结构体的f_op成员中。最终VFS层会给open函数返回一个文件描述符fd(与struct file对应)，其他函数就可以根据这个文件描述符fd找到struct file，并进行对应字符设备的函数操作。</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/chrdev12.jpg"></p><p>其中在VFS层中的操作过程会在下面分析。</p><h2 id="设备号及分配"><a href="#设备号及分配" class="headerlink" title="设备号及分配"></a>设备号及分配</h2><p>对于字符设备来说有两种方法分配设备号：mknod和使用函数在驱动程序中创建。而在使用函数在驱动程序中创建时，通常有两个选择，静态分配(<code>register_chrdev_region()</code>)和动态分配(<code>alloc_chrdev_region()</code>)。在分配成功时返回0，失败时返回负的错误码。还可以使用<code>include/linux/kdev_t.h</code>中特定的宏来进行设备号相关操作，<code>MAJOR(dev_t dev)</code>可以获取主设备号，<code>MINOR(dev_t dev)</code>可以获取次设备号，<code>MKDEV(int major, int minor)</code>可以将一对主次设备号转换为dev_t类型的设备编号。</p><p>对于内核开发者来说，不能向自己的设备驱动程序随便定义设备号。对于内核源码的标准发行版，在<code>Documentation/admin-guide/devices.txt</code>下可以看到常用设备分配的设备号，在进行静态分配设备号时需要避开防止冲突。</p><p>动态注册设备号允许在用户层来创建，当内核检测到设备时，通过udevd守护进程机制，借助udevd规则创建内核对象进行设备管理，借助tmpfs在/dev中创建对应项，由于tmpfs的特性，设备节点不再是持久的，在系统关机重启后会消失。</p><p><code>register_chrdev_region()</code>和<code>alloc_chrdev_region()</code>函数都在<code>fs/char_dev.c</code>中定义。静态分配时，<code>register_chrdev_region()</code>通过传入的dev_t设备编号和设备数确定注册的范围，并在这个范围中遍历注册字符设备，注册失败则调用<code>__unregister_chrdev_region()</code>来卸载字符设备并使用kfree来释放kzalloc申请的空间。对于<code>__unregister_chrdev_region()</code>来说，它多了一个baseminor参数来确定要求注册的次设备号范围的第一个序号，同时在内部调用<code>__register_chrdev_region()</code>时所传入的major值为0，这样<code>__register_chrdev_region()</code>判断major等于0时，通过<code>find_dynamic_major()</code>函数从散列表的末尾表项开始继续向后寻找一个与尚未使用的主设备号对应的空冲突表。</p><p>如果观察<code>register_chrdev_region()</code>和<code>alloc_chrdev_region()</code>的异常判断和返回值，可以发现它们都使用了两个宏：<code>IS_ERR()</code>和<code>PTR_ERR()</code>，这是两个很有趣的实现。</p><p>在<code>include/linux/err.h</code>中实现了一个宏<code>#define IS_ERR_VALUE(x) unlikely((unsigned long)(void *)(x) &gt;= (unsigned long)-MAX_ERRNO)</code>来判断是否是错误码，并且这个宏对不同的体系架构具有普适性(a per-architecture thing)。Linux内核中，错误码都是以负数的形式存在，由<code>#define MAX_ERRNO 4095</code>可知，错误码的范围为[-4095,-1]。在unsigned long下面，-4095转换为0xFFFFF001，-1转换为0xFFFFFFFF，所以上述范围就变为了[0xFFFFF001,0xFFFFFFFF]。</p><p>Linux上用户空间和内核空间是被分开的，在内核空间中操作系统划分出一块保留区域，这个范围内的内核地址是不能被分配的。</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/chrdev13.jpg"></p><p>由上图可知这块保留区域在内存的中的地址恰好就是之前unsigned long转换后错误码的范围。<code>IS_ERR()</code>传入的是一个指针类型的参数，它直接判断这个传递的指针是否是在有效的内存地址，此时如果传入的是转换为指针类型的错误码就会判断为保留地址，即得出这个传入的指针不是分配的内存地址、而是被转换为指针类型的错误码的结论。之后<code>PTR_ERR()</code>直接将这个指针转换为long类型的错误码值并返回。</p><p>通过利用保留区域和MAX_ERRNO，成功将有效的内存地址和错误码区分开来。</p><h2 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h2><p>字符设备作为设备文件，通过inode中的成员i_cdev直接指向cdev结构体。在<code>include/linux/cdev.h</code>中可以看见cdev的原型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct cdev &#123;</span><br><span class="line">struct kobject kobj;</span><br><span class="line">struct module *owner;</span><br><span class="line">const struct file_operations *ops;</span><br><span class="line">struct list_head list;</span><br><span class="line">dev_t dev;</span><br><span class="line">unsigned int count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>kobject是内核设备模型的核心部分，提供了引用计数、父指针等字段。当初始化之后，kobject的引用计数设为1，如果引用计数不清零，则该对象就一直保持在内存中。当引用计数为零时，对象可以被撤销，相关内存也可以被释放。通过<code>kref_get()</code>和<code>kref_put()</code>可以增加和减少引用计数。</p><p>当kobject嵌入cdev中时，cdev结构体成为对象模型层次架构中的一部分，使得cdev能拥有<code>cdev-&gt;kobj.parent</code>等指针操作。owner表示驱动程序模块所有者字段。list作为一个链表来包含设备特殊文件的inode。dev是dev_t类型的设备号。count用来记录该设备下面关联的次设备号的数量。ops作为最重要的的成员，是一个file_operations结构体，内核通过<code>cdev-&gt;ops</code>直接访问该设备的文件操作。</p><p>file_operations结构包含了大量的函数指针，对于每一个所要设置的方法，对应的每个字段都应该指向驱动程序中实现对应操作的函数，而对于不需要实现的方法可以将其设置为NULL。在早期，字符设备的文件操作定义很含糊，在标准上只有一个open操作来向结构传入已经打开的设备的函数指针，从而来进一步操作字符设备。如今字符设备驱动的文件操作越来越多，包含了各种对于设备属性的抽象。除开我们在设备驱动程序中自己编写的文件操作，其实内核本身也提供了预留的文件操作，它们通常以<code>generic_file_</code>作为函数名的开头，例如<code>generic_file_open()</code>、<code>generic_file_read_iter()</code>、<code>generic_file_llseek()</code>等，这些通用实现为文件操作提供了便利。</p><p>由于现实中字符设备驱动的复杂性和多样的设计需求，struct cdev通常是作为一个内嵌的成员变量放在实际的字符设备的数据结构中的。</p><p>在对设备节点分配完成后，在内核对设备进行操作之前，由于内核使用struct cdev结构来表示字符设备，因此需要进行cdev的分配和初始化。由于我们将cdev嵌入到自己的数据结构中，所以通过<code>cdev_init()</code>初始化已经分配到的结构并绑定已经定义的file_operations。之后调用<code>cdev_add()</code>向内核添加该字符设备，同样，它也是成功返回0，失败返回负的错误码。当需要移除字符设备时，通过<code>cdev_del()</code>进行移除。</p><p>那么对于一个最基本的read文件操作，是怎么通过用户空间的C库API传递到底层文件设备进行读取的呢？让我们先从VFS入手。</p><h2 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h2><p>VFS全称Virtual File System，是内核子系统，为用户空间提供文件和文件系统相关的接口。要理解虚拟文件系统，应先看看Linux下的文件系统。VFS的主要代码位于<code>include\linux\fs.h</code>。Linux秉承“一切皆文件”的理念，整个系统由成千上万的文件构成，使用目录结构来管理组织存储的数据。Linux支持不同的文件系统，如Ext2、Ext4、XFS、Btrfs、VFAT等，然而不同的文件系统具有非常大的特性差异，为了将这些具体特性与上层应用层和下层内核层分离开来，需要提供一层关键的文件处理机制，这就是VFS。VFS向下对底层独立的文件系统导出接口进行抽象，向上提供用户空间到系统调用访问文件系统的功能。</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/chrdev11.jpg"></p><p>对于每个文件系统的实现来说，它们导出一组通用接口提供给VFS。对于块设备文件来说，使用页缓存、块缓存等缓冲区用来缓存文件系统与块设备层之间的请求。VFS采取一种大而全的思想，它提供了一种结构模型，包含了文件系统所具备的全部组件，然后通过函数指针来进行定义。</p><p>对于用户空间和内核空间来说，两者之间在处理文件时面向的对象是不一样的。对于用户程序来说，一个文件由一个文件描述符标识，文件描述符由内核分配，只在一个进程内部有效。对于内核来说，则是通过inode来描述文件的元数据和指向文件数据的指针。inode_hashtable支持根据inode编号和超级块快速访问inode。</p><p>我们先从4个主要的对象类型来分析VFS：super_operations(超级块对象)、inode_operations(索引节点对象)、dentry_operations(目录项对象)、file_operations(文件对象)。每种对象作为一个结构体指针来实现，每个结构体里面包含对应的指向其文件操作的函数指针。这4种对象由4个结构体来声明：super_block、inode、dentry、file。</p><p>各类文件系统都要实现超级块对象，它用来描述整个文件系统的信息，包括设备标识符、文件系统子类型、文件大小上限、超级块方法、挂载标志等。索引节点对象包括了内核操作文件及目录时的信息，如散列表、访问权限、引用计数、实际设备标识符、相关的超级块、相关的地址映射等。</p><p>VFS把目录当作文件来看待，所以目录项能用来表示具体文件的位置，并反映了文件系统的树状关系。目录项对象没有对应的硬盘对象结构，因此也不存在是否被修改的标志。目录项对象具有4种状态：空闲、被使用、未被使用、负状态。处于空闲状态的目录项对象不包括有效的信息，且还没有被VFS使用。被使用状态对应一个有效的inode，且d_count为正值。未被使用状态也对应一个有效的inode，但d_count为0，该目录项不会快速撤销，有利于之后继续使用。负状态的目录项没有对应的有效inode，虽然索引节点已经被删除，但是目录项还是被保留。dentry结构不仅易于处理文件系统，还能通过dcache提高系统性能。当访问一个路径时，如果能在目录项缓存中找到该路径名，就能节约大量时间，就算没有找到该路径名，也能将其解析之后放入缓存以便以后快速查找。由于文件系统的特性，文件访问通常是具有空间及时间的局部性，程序很有可能会在同一个目录下访问多个文件或者某个文件会被多次访问，此时由于dcache的存在，其路径命中几率会大大增加。</p><p>文件对象表示进程打开的文件在其内存中的表示，用于搭建进程和磁盘上的文件的对应关系。由于多个进程可能同时操作同一个文件，因此一个文件可能存在多个对应的文件对象，但这个文件对应的inode和dentry应该是唯一的。</p><p>除了4大文件对象外，还有其他很多与VFS相关的数据结构如vfsmount(表示文件系统的安装点)、file_system_type(描述文件系统功能结构)、fiemap_extent(基于extent存储的数据结构)等。</p><p>那么VFS的这些文件对象如何和进程关联到一起？主要是下面这3种数据结构：files_struct、fs_struct、namespace。文件描述符fd是用来描述打开的文件的，每个进程用一个files_struct结构来记录文件描述符的使用情况，这个files_struct结构称为用户打开文件表，它是进程的私有数据。fs_struct由进程描述符的fs指向，包括了文件系统与进程相关的信息，其中count作为共享同一fs_struct的进程数目，同时用dentry来表示根目录、当前目录等。namespace由进程描述符的mmt_namespace指向，通常来说内核使用的是单进程命名空间。</p><p>一个文件系统对应一个超级块和一个vfsmount。超级块中的s_type指向具体的file_system_type，具体的文件系统通过fs_supers链接具有同一种文件类型的超级块，同一种文件系统类型的超级块由s_instances进行链接。之后进程通过task_struct中的files找到files_struct结构，其中具有成员文件描述符数组fd_array，也就是文件对象数组的索引值。文件对象通过域f_dentry找到d_inode对应的索引节点，建立起文件对象与进程的关联。</p><h2 id="从read出发"><a href="#从read出发" class="headerlink" title="从read出发"></a>从read出发</h2><p>在了解VFS之后，我们回过头来看看用户空间的read到底是怎样读取字符设备的。</p><p>假如现在已经实现了一个简单的字符设备驱动，且通过模块的方式加载了驱动，并赋予设备<code>/dev/dev_fifo0</code>相应的权限。编写了一个测试文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> key_val[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/dev_fifo0&quot;</span>, O_RDWR);</span><br><span class="line">    read(fd, &amp;key_val, <span class="number">64</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该测试程序直接调用read系统函数，函数原型在<code>&lt;unistd.h&gt;</code>中定义如下<br><code>ssize_t read (int __fd, void *__buf, size_t __nbytes)</code><br>运行<code>$ man 2 read</code>了解函数相关信息<br>对应的三个参数为文件描述符、缓冲区起始地址、字节数。根据描述，在支持查找的文件上，读取操作从文件偏移量f_pos开始，以读取的字节数nbytes递增，若文件偏移量等于或大于文件结尾，则停止read。当读取完成所有字节数则返回0，如果返回一个比字节数小的正值则表示读取成功但可能遇到EOF、管道关闭或信号中断，如果读取错误则返回负的错误码。<br>由于使用系统函数，所有它通过系统调用执行陷入指令切换到内核态。为了追踪这个系统函数，我们需要对可执行文件进行反编译来分析汇编文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-gcc -static -g test.c -o test</span><br><span class="line">$ arm-linux-gnueabihf-objdump -D -S test &gt; test.s</span><br></pre></td></tr></table></figure><p>查看汇编代码：</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200917095943.png"></p><p>在main中可以看到，当运行到<code>read(fd, &amp;key_val, 64);</code>时，通过子程序跳转bl跳转到<code>__libc_read</code>。</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200917100022.png"></p><p>之后在<code>__libc_read</code>中，mov.w指令将立即数3传给16位的ip指令指针寄存器，在下一条指令通过bl跳转到<code>__libc_do_syscall</code>。</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200917100203.png"></p><p>在<code>__libc_do_syscall</code>中，mov指令将ip指令指针寄存器传给r7寄存器，然后在下一条指令中用svc系统调用指令转到内核空间中。此处的svc就是ARM汇编中swi的更新替代指令，在发生软中断后直接跳转到异常向量表处。</p><p>在<code>arch/arm/kernel/entry-common.S</code>里可以看到swi的入口<code>ENTRY(vector_swi)</code>。在这下面我们可以看到一段注释<code>Pure EABI user space always put syscall number into scno (r7).</code></p><h2 id="OABI和EABI"><a href="#OABI和EABI" class="headerlink" title="OABI和EABI"></a>OABI和EABI</h2><p>ABI，全称application binary interface，应用程序二进制接口，它使得两个二进制程序模块能够互相兼容。OABI全称old application binary interface，EABI全称embedded application binary interface，两者都是基于ARM平台来讲的。OABI作为ARM系列的第一个ABI，它假设了一个具有浮点运算单元的ARM平台，然而这在没有FPU的机器上会一直请求通信引发内核异常。同时，浮点计算效率也不高。EABI解决了上述问题，优化了嵌入式系统中有限资源内的性能，其浮点性能比OABI高了10倍。</p><p>内核对于OABI和EABI给出了两个system call table，可在<code>arch/arm/include/generated/calls-oabi.S</code>和<code>arch/arm/include/generated/calls-eabi.S</code>找到它们。</p><p>通常来说，可以在make menuconfig中对OABI和EABI进行配置。如果想查看经过某个工具链编译之后的可执行文件采取哪一种配置，可以通过下面的指令进行判断：<br><code>$ readelf -h [file]</code></p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200917095739.png"></p><p>可以看到，在经过arm-linux-gnueabihf-gcc工具链编译之后可执行文件的ABI配置为<code>Version5 EABI, hard-float ABI</code>。</p><h2 id="syscall-table"><a href="#syscall-table" class="headerlink" title="syscall table"></a>syscall table</h2><p>现在回到<code>entry-common.S</code>。<br>通过<code>addne scno, r7,</code>，scno成为了寄存器r7的别名，其值为系统调用号3，<code>adr tbl, sys_call_table</code>读取系统调用表的地址给tbl。</p><p>之后先用对CONFIG_AEABI进行判断决定查找<code>calls-eabi.S</code>还是<code>calls-oabi.S</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_AEABI</span><br><span class="line">#include &lt;calls-eabi.S&gt;</span><br><span class="line">#else</span><br><span class="line">#include &lt;calls-oabi.S&gt;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>最终通过<code>ldrlo pc, [tbl, scno, lsl #2]</code>来调用需求的系统调用。由于<code>__NR_OABI_SYSCALL_BASE</code>是0，所以scno中的值还是为系统调用号3，<code>lsl #2</code>左移两位乘4，tbl为系统调用表sys_call_table的基地址。<code>calls-eabi.S</code>中每个系统调用标号占用4个字节(NATIVE)，所以在基地址上加系统调用号3乘4的值，就可以直接跳入执行<code>sys_read</code>。</p><p><code>sys_read</code>在哪呢？我们在<code>fs/read_write.c</code>中可以找到它的定义：<code>SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)</code>。</p><h2 id="宏定义的艺术"><a href="#宏定义的艺术" class="headerlink" title="宏定义的艺术"></a>宏定义的艺术</h2><p>SYSCALL_DEFINE3作为一个明显的宏，让我们追根溯源一下看看它到底如何展开。先从<code>include/linux/syscalls.h</code>看起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span><br></pre></td></tr></table></figure><p>其中省略号代表可变部分，双#进行分割链接，单#将参数转为字符串。此时宏被展开为<code>SYSCALL_DEFINEx(3, _read, __VA_ARGS__)</code>。<br>根据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define SYSCALL_DEFINEx(x, sname, ...)\</span><br><span class="line">SYSCALL_METADATA(sname, x, __VA_ARGS__)\</span><br><span class="line">__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span><br></pre></td></tr></table></figure><p>此时宏被展开为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_METADATA(_read, 3, __VA_ARGS__)\</span><br><span class="line">__SYSCALL_DEFINEx(3, _read, __VA_ARGS__)</span><br></pre></td></tr></table></figure><p>为了后面高效率的分析宏展开，我们假设此时CONFIG_FTRACE_SYSCALLS未定义。根据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define __SYSCALL_DEFINEx(x, name, ...)\</span><br><span class="line">asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))\</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可将之前的宏展开为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_read(__MAP(3,__SC_DECL,__VA_ARGS__))</span><br></pre></td></tr></table></figure><p>同时根据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define __MAP0(m,...)</span><br><span class="line">#define __MAP1(m,t,a) m(t,a)</span><br><span class="line">#define __MAP2(m,t,a,...) m(t,a), __MAP1(m,__VA_ARGS__)</span><br><span class="line">#define __MAP3(m,t,a,...) m(t,a), __MAP2(m,__VA_ARGS__)</span><br><span class="line">#define __MAP4(m,t,a,...) m(t,a), __MAP3(m,__VA_ARGS__)</span><br><span class="line">#define __MAP5(m,t,a,...) m(t,a), __MAP4(m,__VA_ARGS__)</span><br><span class="line">#define __MAP6(m,t,a,...) m(t,a), __MAP5(m,__VA_ARGS__)</span><br><span class="line">#define __MAP(n,...) __MAP##n(__VA_ARGS__)</span><br><span class="line">#define __SC_DECL(t, a)t a</span><br></pre></td></tr></table></figure><p>最终将宏展开为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_read(unsigned int fd, char __user *buf, size_t count);</span><br></pre></td></tr></table></figure><p>这就是系统调用sys_read的原样。经过这些宏嵌套、宏展开，我们可以知道SYSCALL_DEFINE后面所带的数字就是参数的个数n，其内部第一个参数为系统调用名字的后半部分，之后紧跟n对系统调用参数类型及名称。</p><p>为什么要使用如此多的宏定义而不是采取直接展开的方式呢？主要是因为在以前旧版本的内核中，对于不同体系架构的平台来讲，在用户空间里要将系统调用的32位参数在64位寄存器中进行正确的符号扩展，但由于某些平台的原因导致这个扩展可能失败，访问到错误的地址空间或产生其他异常，导致系统崩溃。</p><p>于是内核增加了宏展开将所有参数转换为64位long类型，在去为所需的类型的、进行转换，避免有符号、无符号之间的错误。</p><p>宏的艺术不止于此，例如在<code>include/linux/build_bug.h</code>中有更精彩的实现。</p><h2 id="read之后"><a href="#read之后" class="headerlink" title="read之后"></a>read之后</h2><p>把视线切换回到<code>fs/read_write.c</code>，可以发现在sys_read中有一个重要的函数<code>vfs_read()</code>。在内核版本5.8.7中多了一层ksys_read。<br><code>vfs_read()</code>原型如下：<br><code>ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)</code><br>sys_read先通过<code>file_pos_read()</code>读取file的f_pos，即文件读写位置，最终向<code>vfs_read()</code>传入file结构、用户空间缓存、读取字节长度、文件读取位置。在确认读写区域有效及读写长度在范围内之后，执行双下划线的底层调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ssize_t __vfs_read(struct file *file, char __user *buf, size_t count,</span><br><span class="line">   loff_t *pos)</span><br><span class="line">&#123;</span><br><span class="line">if (file-&gt;f_op-&gt;read)</span><br><span class="line">return file-&gt;f_op-&gt;read(file, buf, count, pos);</span><br><span class="line">else if (file-&gt;f_op-&gt;read_iter)</span><br><span class="line">return new_sync_read(file, buf, count, pos);</span><br><span class="line">else</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合之前在VFS的信息，可以知道，file直接找到成员f_op，即一个file_operations对象。通过f_op直接找到字符设备中的设备读取方法，实现字符设备驱动中的设备读写。读写成功后，函数<code>fsnotify_access()</code>就能通知文件被读取，<code>add_rchar()</code>增加当前进程读取字节数，然后通过<code>inc_syscr()</code>增加当前进程系统调用次数。</p><p>就经过这样一个流程，用户空间的read就与内核空间的字符设备read连结在一起。</p><h2 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h2><p>read与fread有什么不同？系统调用是面向底层的，直接通向操作系统内部的接口，用户态通过系统调用利用软中断切换到内核态，在内核中通过调用内核相关函数实现相应功能。而库函数通常是在用户空间地址执行的，通过将API进行封装和整合， 面向复杂情况下的应用开发。由于大部分库函数并不使用系统调用，不会产生内核上下文切换，因此库函数的效率远远大于系统调用。即使在某些库函数中使用到系统调用，但由于库函数采取缓冲区等措施，因此也比本身系统调用的性能高。</p><h2 id="GOT和PLT"><a href="#GOT和PLT" class="headerlink" title="GOT和PLT"></a>GOT和PLT</h2><p>当我们使用x86_64-linux-gcc动态编译时，与静态编译有什么不同？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g test.c</span><br><span class="line">$ objdump -D -S a.out &gt; objdump.s</span><br></pre></td></tr></table></figure><p>查看汇编代码，可以在main里得到如下信息：</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918102441.png"></p><p>程序跳转为地址为0x10a0的<code>read@plt</code>。</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918102517.png"></p><p>可以看出，通过<code>4c0: e5bcfb00 ldr pc, [ip, #2816]!;</code>，将ip寄存器值加2816偏移量读入程序计数器，并将新地址ip+2816写入中断优先寄存器，进入中断。</p><p>使用<code>$ objdump -R a.out</code>得出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a.out:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000003da0 R_X86_64_RELATIVE  *ABS*+0x00000000000011a0</span><br><span class="line">0000000000003da8 R_X86_64_RELATIVE  *ABS*+0x0000000000001160</span><br><span class="line">0000000000004008 R_X86_64_RELATIVE  *ABS*+0x0000000000004008</span><br><span class="line">0000000000003fd8 R_X86_64_GLOB_DAT  _ITM_deregisterTMCloneTable</span><br><span class="line">0000000000003fe0 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.5</span><br><span class="line">0000000000003fe8 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line">0000000000003ff0 R_X86_64_GLOB_DAT  _ITM_registerTMCloneTable</span><br><span class="line">0000000000003ff8 R_X86_64_GLOB_DAT  __cxa_finalize@GLIBC_2.2.5</span><br><span class="line">0000000000003fb8 R_X86_64_JUMP_SLOT  __stack_chk_fail@GLIBC_2.4</span><br><span class="line">0000000000003fc0 R_X86_64_JUMP_SLOT  close@GLIBC_2.2.5</span><br><span class="line">0000000000003fc8 R_X86_64_JUMP_SLOT  read@GLIBC_2.2.5</span><br><span class="line">0000000000003fd0 R_X86_64_JUMP_SLOT  open@GLIBC_2.2.5</span><br></pre></td></tr></table></figure><p><code>read@GLIBC_2.2.5</code>的绝对地址为0x3fc8。用gdb调试追踪一下read。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ (gdb) x&#x2F;8x 0x3fc8</span><br><span class="line">$ (gdb) disassemble 0x00001050</span><br><span class="line">$ (gdb) disassemble 0x00001060</span><br><span class="line">$ (gdb) disassemble 0x00000000</span><br></pre></td></tr></table></figure><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918105016.png"></p><p>可以看到没有加载符号表，找不到包含指定地址的函数。进入gdb，将断点设置为main，查看共享库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ (gdb) info sharedlibrary</span><br></pre></td></tr></table></figure><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918105445.png"></p><p>可以看见提示说共享库缺少调试信息。根据from的地址增加so文件的符号表，增加elf的源路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ (gdb) add-symbol-file &#x2F;usr&#x2F;lib&#x2F;debug&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.31.so 0x00007ffff7fd0100</span><br><span class="line">$ (gdb) add-symbol-file &#x2F;usr&#x2F;lib&#x2F;debug&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.31.so 0x00007ffff7de9630</span><br><span class="line">$ (gdb) dir ~&#x2F;glibc&#x2F;glibc-2.31&#x2F;elf&#x2F;</span><br></pre></td></tr></table></figure><p>此时再次查看<code>read@plt</code></p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918110222.png"></p><p>继续查看jmpq的完整地址，查看其在符号表中的对应信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ (gdb) x&#x2F;a 0x555555557fc8</span><br><span class="line">$ (gdb) info symbol 0x7ffff7ed4fa0</span><br></pre></td></tr></table></figure><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918111050.png"></p><p>发现能在so的text section中找到，此时程序运行到read的动态链接就能完成。整个共享库的地址翻译，离不开GOT和PLT。</p><p>PLT全称Procedure Link Table(过程链接表)，GOT全称Global Offset Table(全局偏移表)，两者在代码共享及动态库上扮演着重要的角色。在二进制文件中，有一个叫relocations的东西，它能够在工具链静态链接时填充或者在运行时动态链接时填充。它在二进制文件中的作用就是确定某个符号的值，然后将这个符号的值写到某个偏移地址处。</p><p>使用readelf查看可执行文件：</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918112553.png"></p><p>可以看到在<code>.rela.plt</code>的section下，read的符号值为0，存在一个偏移地址为<code>0x000000003fc8</code>，如果使用gdb查看这个位置的机器码的话，会得到下面的结果：</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918113505.png"></p><p>可以看到从offset 0x2位置开始，寄存器rax的值是未确定的，此时对于%al来说，只能以一个0x00作为偏移，来读取此处内存地址的内容。然而实际上，这个寄存器的偏移地址会在链接后进行补全，最后形成真正的地址偏移。在链接阶段，编译器如果发现有代码定义在动态库，链接器会生成一小段额外代码取代原来的地址进行链接重定位，从而进行运行时的重定位。此时PLT将这个区域进行翻译，实现对另一个地址的跳转，之后通过GOT找到so中真正的地址。ELF将GOT拆分为.got和.got.plt，将PLT拆分为.plt和.plt.got，前者保存全局变量引用的地址，后者保存函数引用的地址，在ELF信息中都能看见。而对于.rela来说，.rela.dyn包含relocations动态段的填充地址，.rela.plt包含relocations的plt的偏移量，通过偏移量来找到GOT表项的地址。</p><p>PLT表结构第一项为公共表项，下面是每个动态库函数有一项，并从对应的GOT表项中读取目标函数地址。GOT表前三项为.dyn段地址、link_map数据结构地址和<code>_dl_runtime_resolve</code>函数地址，在动态链接时进行填充。进程加载后，PLT指向不变，动态链接器在ELF的.dynamic段里面找到GOT的地址，当外部函数被调用时才执行重定位。</p><p>GOT还实现了延迟重定位的功能，确保在动态库函数被调用时才作解析，还能获取重定位是否完成的标志，这就是PLT stub实现的延迟绑定技术(lazy binding)。Linux还分类了公共函数，增加.plt的公共入口，避免PLT指令过多。</p><h2 id="回到read"><a href="#回到read" class="headerlink" title="回到read"></a>回到read</h2><p>了解了PLT和GOT之后，动态库的链接也不再那么神秘。如果把目光重新放回read，可能会发现一个函数：<code>new_sync_read()</code>。在<code>__vfs_read()</code>里面，通过对file成员f_op的文件操作函数判断，f_op有read就走read，f_op有read_iter就走<code>new_sync_read()</code>。如果我们查看<code>fs/ext4/file.c</code>、<code>fs/btrfs/file.c</code>中file_operations结构的定义，可以发现在Ext4、Btrfs这些文件系统都不再使用read，取而代之的是read_iter。</p><p>在剖析read_iter之前，先来看下这3个结构：iovec、kiocb、iov_iter。iovec定义在<code>include/uapi/linux/uio.h</code>中，是POSIX标准1003.1g定义的，需要表示io向量的基址和大小。iov_iter定义在<code>include/linux/uio.h</code>中，作为iovec结构的迭代器，处理用户空间提供的数据缓冲区，普遍用于内存管理和文件系统管理。kiocb定义在<code>include/linux/fs.h</code>中，表示kernel io control block，用来记录io操作的完成状态。在<code>new_sync_read()</code>中，先调用<code>init_sync_kiocb()</code>初始化内核io控制块，其中通过<code>iocb_flags()</code>设置状态。此时对于这个判断通常分为O_DIRECT和使用缓存，用<code>io_is_direct()</code>判断，O_DIRECT绕过内核缓存模式，直接进行磁盘的读写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline bool io_is_direct(struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">return (filp-&gt;f_flags &amp; O_DIRECT) || (filp-&gt;f_mapping-&gt;host-&gt;i_flags &amp; S_DAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内核io控制块初始化之后，将传入的读写地址赋给kiocb，调用<code>iov_iter_init()</code>初始化iovec迭代器。iovec中存放着用户空间传入的数据和长度，使用iov_iter减少了内核在数据缓冲区中出错的可能，通过计数、copy等原子操作修改数据。最终，<code>call_read_iter()</code>方法将kiocb、iov_iter3者传入驱动设备的read_iter操作中。</p><p>之前说过，驱动设备预留了文件操作的通用实现。对于文件系统的read_iter来说，不可避免地会用到<code>generic_file_read_iter()</code>。如果kiocb有效且不用等待，就可以在文件的偏移量起始位置进行写回直到结束。</p><p>接下来，read有两个选择，首先判断kiocb的flag是否是Direct IO方式，如果是这个方式则用<code>filemap_write_and_wait_range()</code>确保页是最新的，然后使用<code>mapping-&gt;a_ops-&gt;direct_IO()</code>来访问数据，其中direct_IO是address_space_operations结构里的函数。当遇到iovec读完、遇到EOF、返回错误码、读到DAX文件等情况，此时直接返回。</p><p>如果不是Direct IO方式的时候，调用<code>generic_file_buffered_read()</code>，进行缓存方式的文件读取。这种方式用到了页高速缓存，减少了磁盘的io操作，加快了读写速度。Linux对于内存管理采用了基数树(radix tree)的方法，每个inode有一个address_space对象，结构address_space通过radix树跟踪绑定到地址映射上的核心页。</p><p>在<code>generic_file_buffered_read()</code>中，使用了大量的goto语句来梳理逻辑和处理错误。对于一个正常的流程来说，当读取一个文件时，先要调用<code>find_get_page()</code>，检测数据是否已经缓存，如果没有缓存，则执行预读取<code>page_cache_sync_readahead()</code>、<code>page_cache_async_readahead()</code>从硬盘中读取页。如果内存中没有pagecache，则通过<code>page_cache_alloc_cold()</code>将page加入到<code>add_to_page_cache_lru()</code>，通过LRU算法将数据加载入缓存页。</p><p>在确保找到页缓存且页缓存为最新页后，调用<code>copy_page_to_iter()</code>将内存中的数据拷贝到用户空间，最后用<code>file_accessed()</code>更新文件的最后访问时间。就这样，当击中最新页缓存且iov_iter计数大于0时，拷贝缓存页的数据，当未击中页缓存时，则执行预读取或分配新的缓存页，利用goto语句完成整个迭代器对文件的读取。</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/chrdev1.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈九号秘事S03.E03中的字谜</title>
      <link href="2019/06/29/Inside_No.9_S03_E03_riddle/"/>
      <url>2019/06/29/Inside_No.9_S03_E03_riddle/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Inside.No.9.S03.E03.the.riddle.of.the.Sphinx<br>斯芬克斯的谜语</p></blockquote><p>开胃菜：</p><p>先来看看这个 What’s long and hard and full of semen？通过谐音双关，semen变换为seamen，谜底也就出来了： submarine。</p><p>如果是这道题呢？</p><p><strong>I TEACH WILD CREATURE WITHOUT HOSPITAL BUILDING – (12)</strong></p><p>12指谜底由12个字母组成。  </p><p>在clue的开头和结尾总是包含两个解谜提示来告诉谜底的含义，其他部分就是wordplay。WILD就是一个anagram-indicator，代表字母可以变换顺序来重新排列（例如upset，excited，insane），所以要去mix up字母。要mix up那些字母呢？</p><p>在这我们就要考虑I TEACH CREATURE，可以发现它重复了两个字母。再看WITHOUT HOSPITAL，HOSPITAL就代表A&amp;E（Accident&amp;Emergency）。它也恰好是上一个句子里重复的两个字母，WITHOUT提示我们要把它删除。删除之后只剩下12个字母，所以要把它重新排列为一个含12个字母的字母变位词。再看最后一个单词BUILDING，将这12个字母重新排列后成为一个指代BUILDING的单词，谜底即为<strong>ARCHITACTURE</strong>。</p><p>留个谜题：What’s pink and hard in the morning？</p><p>主菜：</p><p>来看看正宗的crossword吧。</p><p><img src="/images/Inside_No.9_S03_E03_riddle/empty-crossword.png"></p><p>crossword分为横行across和纵行down。每个开头都有标号，通过给出的提示，来填满所有空格。</p><p>先来看看ACROSS的提示和解法。</p><p><strong>1. To wound and wander destitute (4,3,3)</strong></p><p>TO WOUND AND WANDER作为表示动作的动词或形容词，用来描述destitute的4-3-3词语就是Down-and-out。</p><p><strong>9. Degas evacuated and bathed before putting big picture in bog</strong></p><p>如果要evacuate一些东西，就是指要clean它。所以就把degas的中间部分去掉，只剩DS，bathed也指swam，before提示要把swam放在ds前面。big picture就是指plan，把它put in在swam和ds的中间，就形成了swamplands，也是bog的意思。</p><p><strong>12. I hear American poet solved the riddle of the pseudo-hotel patron</strong></p><p>这个美国诗人是Edgar Guest。riddle solved就是mystery guessed。联系pseudo-hotel patron，谜底就是Mystery guest。</p><p><strong>15. Some smart aleck, no wit, allegedly (4,2,3)</strong></p><p>与know-it-all（贬义）类似。</p><p><strong>18. Tory leader on board for English flower (5)</strong></p><p>Tory的首字母是t，剩下四个字母和T组成一个单词。flower这里双关，代指流体。English表示英国。而board有一个意思是rent，和T就组成了Trent，它是一条英国英格兰中部的河流。</p><p>再看看DOWN的提示和解法：</p><p><strong>1. Indian national product of French-Italian agreement</strong></p><p>关键词是法国的，而又是意大利中一种表示同意(合约和同意双关)的方式(si)，又要和印度相关，所以谜底是desi。</p><p><strong>2. This cover sounds like a 50 Cent song</strong></p><p>考察的是homophone。50 Cent song指代Rap，一个homophone来表示cover又和rap同音，所以谜底为wrap。</p><p><strong>3. A disturbed setter concealed a tiny amount. Why, it’s enough to take one’s breath away.</strong></p><p>setter指代Mr Sphinx，所以就是字母A后面跟着sphinx的anagram。tiny mount在希腊语中是Iota，也是希腊字母表中的第九个字母。why是Y的homophone，也是隐藏的那个tiny amount。要表示take one’s breath away，谜底就是asphyxiation。</p><p><strong>5. Knocked back beer and wine then put on one French undergarment</strong></p><p>Knocked back表示要反写句子。beer的一种是Pils（皮尔森啤酒），wine的一种是Red，反写之后就是slip和der。one在French中是Un。把它们组合在一起就是underslip，和undergarment一个意思。</p><p><strong>7. Catch a train before a poisonous bite</strong></p><p>Catch通常是指抓鱼，a train before指puffer（蒸汽火车），puffer另一个意思是河豚。谜底就是Puffer fish。</p><p><strong>14. Dickens character undertakes to be a cabinet maker</strong></p><p>Dickens指英国作家狄更斯，Oliver Twister是其代表作《雾都孤儿》，Sowerberry是其中人物，也是棺材制造商。</p><p><strong>22. What is a frankfurter’s number-one bun</strong></p><p>frankfurter是指法兰克福香肠，常夹在面包卷中。不以one或bun开头，那就是Neun，它是德语（法兰克福）的数字九。</p><p><strong>23. The origins of a species popularised savage serpents</strong></p><p>Origins提示要使用a species popularised savage里的每个单词第一个字母组成asps，它的意思和serpents一样。</p><p>剧里到最后也没有能够填完crossword，还留下很多空格。不过重看整体，能发现也是隐藏了不少东西的。</p><p><img src="/images/Inside_No.9_S03_E03_riddle/full-crossword.png"><br><strong>I swapped cups</strong></p><p><strong>RIP NHS</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>中国导演电影补全计划(2)</title>
      <link href="2019/04/26/the_road_to_Chinese_director_film_2/"/>
      <url>2019/04/26/the_road_to_Chinese_director_film_2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>正是峰前回雁时</p></blockquote><p>距上一次整理也相隔2个多月了，这次应该是剩下最终的中国导演补片名单了，从第1代导演到第6代导演，从大陆到港台，基本是现阶段对于中国导演领域认知的极限了。接下来应该是注目于亚洲导演了，当然这是后话了。</p><p><strong>王童，张亚璇，王超，王兵，雎安奇，何建军，杨平道，张石川，杨小仲，朱石麟，万古蟾，卜万苍，沈西苓，沈浮，郑君里，崔嵬，桑弧，王苹，凌子风，沈耀庭，吴贻弓，黄蜀芹，吴天明，张暖忻，黄健中，陆小雅，谢飞，滕文骥，郑洞天，米家山，杨亚洲，霍建起，路学长，徐童，周浩，赵亮，李行，白景瑞，陈玉勋，林正盛，易智言，张作骥，胡金铨，方育平，杨凡，张婉婷，严浩。</strong></p><p>（顺序不分先后）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>中国导演电影补全计划(1)</title>
      <link href="2019/02/12/the_road_to_Chinese_director_film_1/"/>
      <url>2019/02/12/the_road_to_Chinese_director_film_1/</url>
      
        <content type="html"><![CDATA[<p>之所以写这篇文章，是因为之前还觉得自己阅片量还可以，但随着对电影这一门艺术的了解越来越深入，愈发觉察自己知之甚少。</p><p>从香港电影到台湾电影，韩国电影到日本电影，苏联电影到美国好莱坞，法国新浪潮到德国表现主义，意大利新现实主义到欧洲先锋电影，乃至巴西的、南美的，甚至说Cult Film、Synth Film、Giallo Film，自己还只停留在表面。</p><p>开启补全计划，一方面为了从自身出发，另一方面为了避免杂乱无章，所以决定从中国导演开始。而在标题后面加个序号，也是为了之后增删改查的便宜。所谓补全，很显然要把该导演的作品看一遍，剔除网络上已找不到的资源之外，大概能把每人的作品看个90%。因此就有必要筛选导演名单。以下所述名单的筛选具有极强的主观意识，属于个人观点。</p><ol><li><p>首先剔除基本只拍烂片的导演，例如毕志飞之流。</p></li><li><p>专注于拍商业片、院线的也去除，一是没那么多时间看这些片子，二是这些之前也看得七七八八了，例如王晶，冯小刚，张艺谋等。</p></li><li><p>偶有好片，但未到精品的也抛弃，例如毕赣，章明，范俭等。</p></li><li><p>能够进入补全名单，但所拍作品基本看完的也不列入，例如李安，忻钰坤，王家卫等。</p></li><li><p>拍过经典，之后随波逐流与市场或者才气不足的也除外，例如陈凯歌，李玉，姜伟，张猛，张黎，管虎，顾长卫，张杨，伍仕贤，李杨等。</p></li><li><p>好片居多，因自己主观而剔除的，例如姜文，宁浩，林超贤，曹保平，陈果等。</p></li></ol><p>剔除名单里，最为可惜的就是第5类导演，在此略过不谈，不再赘述。根据主观的筛选之后，如下的名单就是进入我第一批中国导演补全计划的人(补片顺序不分先后)：</p><p><strong>吴永刚，孙瑜，贾樟柯，费穆，杨德昌，蔡楚生，李睿珺，蔡明亮，娄烨，王小帅，王竞，赵德胤，张元，谢晋，袁牧之，程刚，侯孝贤。</strong></p><blockquote><p>晴天归路好相逐</p></blockquote><p>补片之路漫长，文章掷笔于此，且作一拾遗之处。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RaspberryPi3B的使用问题</title>
      <link href="2018/07/19/dealing_with_RaspberryPi3B/"/>
      <url>2018/07/19/dealing_with_RaspberryPi3B/</url>
      
        <content type="html"><![CDATA[<p>树莓派官网raspberrypi.org下载Raspbian stretch with desktop，通过Win32DiskImager烧录进16gSD卡中，出现如下错误：</p><p><img src="/images/dealing_with_RaspberryPi3B/raspberry.jpg"></p><p>在官网上找到类似问题，<a href="https://raspberrypi.stackexchange.com/questions/17023/panic-vfs-unable-to-mount-root-fs-on-unknown-block179-2%EF%BC%8C">https://raspberrypi.stackexchange.com/questions/17023/panic-vfs-unable-to-mount-root-fs-on-unknown-block179-2，</a> 但是没有得到解决。</p><p>通过百度得知可以使用<code>sudo fsck -f -v -r /dev/sdb2</code>之类的fsck命令解决。在deepin上使用此命令后错误没有得到解决。</p><p>尝试使用官网的noobs进行安装。使用DiskGenius对已经烧录过的SD卡进行重新分区并格式化，烧录noobs系统。安装时一直循环resizing fat partition。</p><p>解决方法：在使用DiskGenius之后，再使用电脑自带的格式化再次格式化，文件系统为FAT32，分配单元大小为16kb。最终成功安装。</p><p>使用noobs安装则不能开启expand Filesystem。安装之后开启修改国内源，如果没有文件权限则使用chmod命令修改权限，在Raspberry Pi Configuration中开启SSH和VNC。sudo ifconfig可以查看ip地址。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>扫雷MineSweeper的设计</title>
      <link href="2018/03/05/MineSweeperDesign/"/>
      <url>2018/03/05/MineSweeperDesign/</url>
      
        <content type="html"><![CDATA[<h4 id="MineSweeper的实现思路"><a href="#MineSweeper的实现思路" class="headerlink" title="MineSweeper的实现思路"></a>MineSweeper的实现思路</h4><ul><li>使用二维的vector容器数组存储gameMap</li><li>使用结构体MineBlock存储gameMap信息</li><li>使用枚举法判断周围的地雷数量</li><li>使用递归法进行挖雷</li><li>计算周围地雷数量时要排除本身</li><li>标记分为错误标记(MARKED)和正确标记(WRONG_MARK)，需要对两个标记进行区分(在ui层游戏结束时做绘制区分)</li><li>一个方块如果标记两次会回到UNDIG的状态</li></ul><p>在构造函数里面不做具体初始化，因为构造函数的调用时间不确定<br>界面设置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blockSize = <span class="number">20</span>; <span class="comment">//方块大小</span></span><br><span class="line">offsetX = <span class="number">5</span>; <span class="comment">//横向边距</span></span><br><span class="line">offsetY = <span class="number">5</span>; <span class="comment">//纵向边距</span></span><br><span class="line">scroeboardY = <span class="number">70</span>; <span class="comment">//记分板高度</span></span><br></pre></td></tr></table></figure><p>设置窗口控件固定大小 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">game -&gt; mCol * blockSize + offsetX * 2</span><br><span class="line">game -&gt; mRow * blockSize + offsetY * 2 + scroeboardY</span><br><span class="line">(game -&gt; mCol) * 20 + 5 * 2</span><br><span class="line">(game -&gt; mRow) * 20 + 5 * 2 + 70</span><br></pre></td></tr></table></figure><p>drawPixmap()使用GPU处理，相对减轻了CPU的负担</p><p><code>void QPainter::drawPixmap(int x, int y, const QPixmap &amp; pixmap, int sx = 0, int sy = 0, int sw = -1, int sh = -1)</code><br>通过把pixmap的一部分复制到绘制设备中，在(x, y)绘制一个像素映射。<br>(x, y)指定了要被绘制的绘制设备的左上点<br>(sx, sy)指定了要被绘制的pixmap中的左上点，默认为(0, 0)。<br>(sw, sh)指定了要被绘制的pixmap的大小，默认(-1, -1)，意思是一直到像素映射的右下。<br>当在QPrinter上绘制时，当前像素映射的遮蔽或者它的alpha通道被忽略。</p><p>游戏的四种状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case OVER:</span><br><span class="line">painter.drawPixmap((game -&gt; mCol * blockSize + offsetX * 2) &#x2F; 2 - 12, scroeboardY &#x2F; 2 + 3.5, bmpFaces, 0 * 24, 0, 24, 24);</span><br><span class="line">break;</span><br><span class="line">case PLAYING:</span><br><span class="line">painter.drawPixmap((game -&gt; mCol * blockSize + offsetX * 2) &#x2F; 2 - 12, scroeboardY &#x2F; 2+ 3.5, bmpFaces, 1 * 24, 0, 24, 24);</span><br><span class="line">break;</span><br><span class="line">case WIN:</span><br><span class="line">painter.drawPixmap((game -&gt; mCol * blockSize + offsetX * 2) &#x2F; 2 - 12, scroeboardY &#x2F; 2+ 3.5, bmpFaces, 2 * 24, 0, 24, 24);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">painter.drawPixmap((game -&gt; mCol * blockSize + offsetX * 2) &#x2F; 2 - 12, scroeboardY &#x2F; 2+ 3.5, bmpFaces, 1 * 24, 0, 24, 24);</span><br><span class="line">break;</span><br></pre></td></tr></table></figure><p><code>((game -&gt; mCol) * 20 + 5 * 2))/2 -12</code>先取控件宽度中心，再减去图像大小24的一半12，获得x轴位置<br><code>70 / 2 + 3.5 = 38.5</code>取记分板高度70的一半加3.5，获得y轴位置<br><code>0 * 24</code>第一个图形的sx值<br><code>1 * 24</code>第二个图形的sx值<br><code>2 * 24</code>第三个图形的sx值<br>三个图形的sy值都为0<br>要绘制的pixmap大小即为24</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = game -&gt; currentMineNumber;</span><br><span class="line"><span class="keyword">int</span> posX = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">painter.drawPixmap(posX, scroeboardY / <span class="number">2</span> + <span class="number">1.5</span>, bmpTimeNumber, n * <span class="number">20</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">28</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">painter.drawPixmap(posX - <span class="number">20</span>, scroeboardY / <span class="number">2</span> + <span class="number">1.5</span>, bmpTimeNumber, n % <span class="number">10</span> * <span class="number">20</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">28</span>); <span class="comment">//每次从后面绘制一位</span></span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">posX -= <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>posX = 50</code>获得x轴位置<br><code>70 / 2 + 1.5 = 36.5</code>取记分板高度70的一半加1.5，获得y轴位置<br><code>n % 10 * 20</code>先取最后一位数字<br><code>n /= 10, posX -= 20</code>向前移一位，取得第一位数字</p><p>currentState的状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(game -&gt; gameMap[i][j].currentState)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> UNDIG:</span><br><span class="line">painter.drawPixmap(j * blockSize + offsetX, i * blockSize + offsetY + scroeboardY , bmpBlocks, blockSize * <span class="number">10</span>, <span class="number">0</span>, blockSize, blockSize);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DIGGED:</span><br><span class="line">painter.drawPixmap(j * blockSize + offsetX, i * blockSize + offsetY + scroeboardY, bmpBlocks, blockSize * game -&gt; gameMap[i][j].valueFlag, <span class="number">0</span>, blockSize, blockSize);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MARKED:</span><br><span class="line">painter.drawPixmap(j * blockSize + offsetX, i * blockSize + offsetY + scroeboardY, bmpBlocks, blockSize * <span class="number">11</span>, <span class="number">0</span>, blockSize, blockSize);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BOMB:</span><br><span class="line">painter.drawPixmap(j * blockSize + offsetX, i * blockSize + offsetY + scroeboardY, bmpBlocks, blockSize * <span class="number">9</span>, <span class="number">0</span>, blockSize, blockSize);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WRONG_MARK:</span><br><span class="line"><span class="keyword">if</span>(game-&gt;gameState == PLAYING || game-&gt;gameState == FAULT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果还在游戏中就显示旗子</span></span><br><span class="line">painter.drawPixmap(j * blockSize + offsetX, i * blockSize + offsetY + scroeboardY, bmpBlocks, blockSize * <span class="number">11</span>, <span class="number">0</span>, blockSize, blockSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(game-&gt;gameState == OVER)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果游戏已经结束，就显示标错了</span></span><br><span class="line">painter.drawPixmap(j * blockSize + offsetX, i * blockSize + offsetY + scroeboardY, bmpBlocks, blockSize * <span class="number">12</span>, <span class="number">0</span>, blockSize, blockSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>game -&gt; gameMap[i][j].currentState</code>获得该方块的状态<br><code>j * 20 + 5</code>获得x轴位置<br><code>i * 20 + 5 + 70</code>获得y轴位置<br>根据状态UNDIG，DIGGED，MARKED，BOMB，WRONG_MARK分别绘制相应图像<br>其中比较特殊的是DIGGED和WRONG_MARK</p><p>DIGGED的pixmap的sx选取是通过<code>20 * game -&gt; gameMap[i][j].valueFlag</code>来选取<br>WRONG_MARK的对应绘制图像是要先判断游戏是否结束，然后分别显示不同的图像</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &gt;= (game -&gt; mCol * blockSize + offsetX * <span class="number">2</span>) / <span class="number">2</span> - <span class="number">12</span> &amp;&amp; x &lt;= (game -&gt; mCol * blockSize + offsetX * <span class="number">2</span>) / <span class="number">2</span> + <span class="number">12</span> &amp;&amp; y &gt;= scroeboardY / <span class="number">2</span> + <span class="number">3.5</span> &amp;&amp; y &lt;= scroeboardY / <span class="number">2</span> + <span class="number">3.5</span> + <span class="number">24</span>)</span><br></pre></td></tr></table></figure><p>判断鼠标指针是否点击了faces图案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &gt;= (game -&gt; mCol * <span class="number">20</span> + <span class="number">5</span> * <span class="number">2</span>) / <span class="number">2</span> - <span class="number">12</span> &amp;&amp; x &lt;= (game -&gt; mCol * <span class="number">20</span> + <span class="number">5</span> * <span class="number">2</span>) / <span class="number">2</span> + <span class="number">12</span> &amp;&amp; y &gt;= <span class="number">70</span> / <span class="number">2</span> + <span class="number">3.5</span> &amp;&amp; y &lt;= <span class="number">70</span> / <span class="number">2</span> + <span class="number">3.5</span> + <span class="number">24</span>)</span><br></pre></td></tr></table></figure><p>计算得出鼠标所点击的block的row值和col值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> px = event-&gt;x() - offsetX;</span><br><span class="line"><span class="keyword">int</span> py = event-&gt;y() - offsetY - scroeboardY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row = py / blockSize;</span><br><span class="line"><span class="keyword">int</span> col = px / blockSize;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>脚尖</title>
      <link href="2018/01/15/toes/"/>
      <url>2018/01/15/toes/</url>
      
        <content type="html"><![CDATA[<p>在脚尖的世界里，他觉得自己一直很孤独。每天大部分时间都被袜子所束缚。</p><p>在外界眼中，袜子是彩色的，煞人眼球。</p><p>而对于自己，袜子等于黑暗。</p><p>袜子给自己的，是透不过气的窒息感，是睁不开眼的无所适从。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows10 17035.1000的绿屏问题解决</title>
      <link href="2018/01/12/GSoD_on_Windows10_17035.1000/"/>
      <url>2018/01/12/GSoD_on_Windows10_17035.1000/</url>
      
        <content type="html"><![CDATA[<p>XPS13使用Windows10开发者预览版快速通道更新17035.1000之后，打开电脑一段时间后会出现BAD_POOL_CALLER绿屏，只能通过重启解决。</p><p>在设置-&gt;开发者预览里把快速通道调至慢速通道后，再次绿屏，错误代码为<code>SYSTEM_THREAD_EXCEPTION_NOT_HANDLED</code>，此时不能进入系统主界面。在安全模式中删除Realtek的驱动，还是无效。备份系统所有数据到移动硬盘。尝试不删除数据重置电脑，出现“计算机意外地重新启动或遇到错误，windows安装无法继续”。回滚系统。尝试删除个人数据重置电脑，再次出现“计算机意外地重新启动或遇到错误，windows安装无法继续”，此时无法回滚。尝试运行oobe里的msoobe.exe，还是无效。</p><p>最终只有用u盘重装系统一条路。最后使用一个16g的HP u盘进行了恢复盘安装。通过dell微信客服问来<a href="https://www.microsoft.com/zh-cn/software-download/windows10?linkId=44645463">https://www.microsoft.com/zh-cn/software-download/windows10?linkId=44645463</a> 网址获取镜像。安装u盘时，因为是通过uefi格式安装，所以不修改bios设置会出现问题，修改uefi secure boot和legacy boot都为off，重新进入F12，开始重装系统。过程基本顺利，删除所有分区之后新建分区。从1507更新到1709系统。驱动根据服务标签在<a href="http://www.dell.com/support/home/cn/zh/cndhs1?app=drivers&amp;~ck=mn%E4%B8%8A%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%88%96%E8%80%85%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%9A%84Dell">http://www.dell.com/support/home/cn/zh/cndhs1?app=drivers&amp;~ck=mn上查找，或者直接下载最新的Dell</a> update应用程序自动查找所需驱动。</p><p>退出win10开发者预览通道，慢速和快速都退出，恢复稳定版本。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>中国文学简史与选读之唐宋词史</title>
      <link href="2016/12/09/the_poem_of_Tang_dynasty_and_the_verse_of_Song_dynasty/"/>
      <url>2016/12/09/the_poem_of_Tang_dynasty_and_the_verse_of_Song_dynasty/</url>
      
        <content type="html"><![CDATA[<p><strong>雨霖铃 · 心请人访</strong></p><p>心请人访。免遭狐假①，涉我烟瘴。<br>所从鹤老龟长②，余花谢了，投闲行傍。<br>相顾春来引步，柳亭雨翻巷。<br>又重续、芳草愁烟，便取河声那堪望。</p><p>相逢祥“阳”醉梦泱，或畋游③、既弃渑水④上。<br>玉液不应兼进，殊不系、更无人唱。<br>宴乐西席，杵臼⑤、倏忽逾情溶漾。<br>重分手、垂钓曾约，去日朱藤杖⑥。</p><p>①：出自《战国策·楚策一》“虎求百兽而食之，得狐。……虎以为然，故遂与之行。兽见之皆走，虎不知兽畏己而走也，以为畏狐也。”。此处代指借取别人声势。<br>②：出自《新荷叶·莲萼飘香》。此处代指时间长。<br>③：出自南朝梁 何逊《七召》：“此武材之矫猛，岂能从我而畋游。” 指畋猎游乐。<br>④：古水名，在山东境内。<br>⑤：出自《后汉书·吴佑传》：“时公沙穆东游太学，无粮，乃变服客佣，为佑凭舂。佑与语，大惊，遂共定交于杵臼之间。“比喻交朋友不计较贫富和身分。<br>⑥：出自唐 白居易《朱藤杖紫骢吟》：“ 江州去日朱藤杖，忠州归时紫骢马。”此处代指旧时光。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一千零一个你</title>
      <link href="2016/10/03/the_most_special_you/"/>
      <url>2016/10/03/the_most_special_you/</url>
      
        <content type="html"><![CDATA[<p>读了一首诗，想起来了你。附和了一首。</p><blockquote><p>我越是逃离<br>却越是靠近你<br>我越是背过脸<br>却越是看见你</p><p>我是一座孤岛<br>处在相思之水中<br>四面八方<br>隔绝我通向你</p><p>一千零一面镜子<br>转映着你的容颜<br>我从你开始<br>我在你结束</p><p>—— 埃姆朗·萨罗希《一千零一面镜子》</p></blockquote><p><strong>一千零一个你</strong></p><p>所以我不再想逃离<br>不再背过脸<br>我只是盯着你<br>就这样盯着你<br>把你整个揉入我</p><p>这样<br>你就不再是一个孤岛<br>不再是一个荒凉的沙漠<br>不再是地上的一滩水<br>匆匆蒸发</p><p>一千零一面镜子<br>转映着你的容颜<br>我从你开始<br>和你一起结束</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>爱和喜欢</title>
      <link href="2016/10/02/love_and_like/"/>
      <url>2016/10/02/love_and_like/</url>
      
        <content type="html"><![CDATA[<p>少用爱这一个字眼，多用用“喜欢”。<br>你真的爱她吗？<br>那么惊天动地的字眼，怎能如此平淡地说出来。<br>但你是非常非常，非常非常喜欢她。<br>喜欢她什么呢？<br>可能你也不是很清楚。<br>可是你就是觉得自己很喜欢她。<br>你自动过滤了爱这个字眼。<br>为什么呢？<br>因为，<br>你那样喜欢她。</p><p>你会觉得她身上每个地方都是香的。<br>洗澡后的头发是香的，跑完步的汗味是香的，夏天上课时坐在她后面，看见他的脖颈，也是香的。</p><p>你会觉得她身上每个地方都如此精雕细琢。<br>那鼻梁，那脸颊，那不加修饰的眼睛，那么诱人的身材，长裙下露出的小腿，高跟鞋中的脚背，不经意时的锁骨，双手叉腰的时候，昂头撅嘴的时候。如此可人。</p><p>你会觉得无论她在干什么，都是风姿绰绰，百媚千娇</p><p>喜欢一个人的时候，<br>比爱一个人的时候，<br>更敏感。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>你踮起脚尖</title>
      <link href="2016/10/01/you_tips_toes/"/>
      <url>2016/10/01/you_tips_toes/</url>
      
        <content type="html"><![CDATA[<p>我站在车水马龙之间，除了你的背影，一无所有。<br>你左右脚轮番轻轻踮起脚尖，向着前方迈去。<br>路人眼中，你是雀跃的。<br>可在我的眼里，你就如同宣纸上泛开的墨汁，聚不拢，收不回。<br>你呢，蹦蹦跳跳时又是怎样一副心情？<br>阳光很稀薄，你的背影，却拉长到了我的脚尖。<br>它压在上面，我抬不起脚来。<br>你忽然回头了。<br>不是回眸一笑，我看不清你的表情。<br>你就在稀薄的阳光中，向我冲了过来。<br>你把我拥入怀中。瘦小的你，就这样把我抱住，紧的不可思议。<br>你馥郁的头发把我围绕，勒紧着我的脖子，让我就此窒息在你的怀抱里。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
