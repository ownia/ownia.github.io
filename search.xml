<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SIGKILL Memory Reclaim Expedite</title>
      <link href="2021/01/26/sigkill_memory_reclaim_expedite/"/>
      <url>2021/01/26/sigkill_memory_reclaim_expedite/</url>
      
        <content type="html"><![CDATA[<h2 id="方案一设计-Design-Proposal-v1"><a href="#方案一设计-Design-Proposal-v1" class="headerlink" title="方案一设计(Design Proposal v1)"></a>方案一设计(Design Proposal v1)</h2><p>Andorid系统在杀死进程并回收内存时，并不是即时操作，同时还要保证可用内存保留在一个范围内防止在回收进程内存时系统性能下降。假如进程退出前在不间断的睡眠中阻塞或者由于其他一些操作耗时较长，此时的内存回收时间可能会不可估计。</p><p>通过提高内存回收的速率可以解决上述问题。提出一个方案，修改kill_pid_info的流程，在对pending的状态发送SIGKILL信号后，立即将task_struct标记为受害者，同时将该task_struct挂到内核线程oom_reaper的链表上，之后oom_reaper会接管该进程的vma，隔离内存执行内存回收。使用oom_reaper线程处理victim进程时，即使它无法运行也能执行回收操作。</p><p><img src="/images/sigkill_memory_reclaim_expedite/top.jpg"></p><p>结果调查，Android lowmemorykiller由于内核版本的不同，通常会选择不同的策略来实施lowmemorykiller。无论哪种措施，都要对系统中的进程进行一系列的优先级判断，然后根据设定好的处理逻辑执行kill操作。</p><p>通过init进程lmkd执行杀死进程时，通过系统调用kill对指定要杀的进程pid发送信号，通过驱动lowmemorykiller执行杀死进程时，通过内核函数send_sig传输task_struct和SIGKILL信号。可以看出，无论系统采用哪种方式执行LMK，都会将SIGKILL和对应的进程信息发送给内核的信号模块。</p><p>9652机芯采用的内核版本为4.9，其Android lowmemorykiller的方案为通过lowmemorykiller驱动处理进程。原始的send_sig接口需要传入task_struct，同时比系统调用kill更快的进入signal模块，而oom_reaper需要访问mm_struct的mmap_sem，而在signal模块中对mm_struct进行处理可能会导致信号阻塞，引起其他的风险。</p><p>因此本方案修改了lowmemorykiller驱动中SIGKILL信号的发送方式，使用内核函数kill_pid替代。这样就能够在信号发送之后再对进程的task_struct进行处理，降低了持锁的风险。但是如果受害者进程正在进行coredump时，可能会导致coredump的数据缺失。</p><p><img src="/images/sigkill_memory_reclaim_expedite/trace.jpg"></p><p>由于lowmemorykiller触发具有不确定性，需要判断bad进程来进行kill，所以对于新方案的性能测试需要从两方面入手。一方面是在lowmemorykiller触发的场景下查看匿名页和文件页在开启和关闭优化下的变动情况，以及lowmemorykiller触发时的回收内存的大小和kswapd进程的资源占用。另一方面是测量kill进程时发送信号到进程退出经过的时间，通过执行多次kill操作采集样本分析数据。</p><p>所需开启的trace event为:sched:sched_process_exit、sched:sched_switch、signal:signal_generate、kmem:rss_stat。其中kmem:rss_stat用来查看对应pid对内存的操作，查看mm_struct中4类内存的变化信息。signal:signal_generate用来捕获信号9，确定__signal_send 调用的时机。sched:sched_process_exit和sched:sched_switch分别对进程退出do_exit和do_task_dead时候的时间点进行捕获。</p><p>匿名页与文件页使用情况变化:</p><table><thead><tr><th></th><th>优化功能关闭</th><th>优化功能开启</th></tr></thead><tbody><tr><td>Active(anon) + Active(file) 增加的值</td><td>11933372B</td><td>11307024B</td></tr><tr><td>Active(anon) + Active(file) 减少的值</td><td>11400280B</td><td>10529300B</td></tr><tr><td>Inactive(anon) + Inactive(file) 增加的值</td><td>40040B</td><td>711944B</td></tr><tr><td>Inactive(anon) + Inactive(file) 减少的值</td><td>136656B</td><td>742036B</td></tr></tbody></table><p>优化功能对进程消亡时间的影响:</p><table><thead><tr><th></th><th>优化功能关闭</th><th>优化功能开启</th><th>提升倍数</th></tr></thead><tbody><tr><td>signal_generate到sched_process_exit平均时间差</td><td>0.01505937s</td><td>0.00110683s</td><td>13.61</td></tr><tr><td>signal_generate到sched_switch平均时间差</td><td>0.02152393s</td><td>0.00781319s</td><td>2.75</td></tr></tbody></table><p>根据测试结果，当优化功能开启后，对于Inactive的内存空间的处理吞吐量大大增大。另外，以__send_signal到__schedule(prev_state=x)为采集时间段比较开关优化功能时的耗时，可看出在未开启优化耗时是开启优化耗时的2.75倍。</p><h2 id="方案二设计-Design-Proposal-v2"><a href="#方案二设计-Design-Proposal-v2" class="headerlink" title="方案二设计(Design Proposal v2)"></a>方案二设计(Design Proposal v2)</h2><p>在oom_reaper线程中，有一个值MAX_OOM_REAP_RETRIES，用来控制oom_reaper的重试次数，其中oom_reaper只使用一个try_lock，并会在短暂的睡眠时间尝试10(MAX_OOM_REAP_RETRIES)次。但假如mm_struct中的读写信号量mmap_sem被阻止时，由于采取的策略为try_lock，可能会出现锁竞争的情况，降低内存回收的效率。另外如果产生mmap_sem的争用也会导致lowmemorykiller延迟的进一步扩大。</p><p>该方案不再通过oom_reaper线程执行内存回收，而是在发送SIGKILL信号的进程的上下文中进行内存回收。</p><p><img src="/images/sigkill_memory_reclaim_expedite/top2.jpg"></p><p>通过对系统节点/sys/kernel/lmk_sigkill/lmk_sigkill_on进行写入(0、1、2)可对优化功能进行开启与关闭，方案二兼容方案一的优化。</p><p>优化功能对应标志:</p><table><thead><tr><th>序号</th><th>优化功能</th><th>tcl_lmk_sigkill.h</th><th>oom.h(enum sigkill_state)</th></tr></thead><tbody><tr><td>0</td><td>关闭</td><td>LMK_SIGKILL_CTRL_OFF</td><td>SIGKILL_STATE_OFF</td></tr><tr><td>1</td><td>方案一(expedite_reclaim)</td><td>LMK_SIGKILL_CTRL_EXPEDITE_ON</td><td>SIGKILL_STATE_EXPEDITE</td></tr><tr><td>2</td><td>方案二(reap_mm)</td><td>LMK_SIGKILL_CTRL_REAP_ON</td><td>SIGKILL_STATE_REAP</td></tr></tbody></table><p><img src="/images/sigkill_memory_reclaim_expedite/reap_mm.jpg"></p><p>优化功能对进程消亡时间的影响:</p><table><thead><tr><th></th><th>优化功能关闭</th><th>优化功能开启</th><th>提升倍数</th></tr></thead><tbody><tr><td>signal_generate到sched_process_exit平均时间差</td><td>0.01505937s</td><td>0.00360875s</td><td>4.17</td></tr><tr><td>signal_generate到sched_switch平均时间差</td><td>0.02152393s</td><td>0.02127370s</td><td>1.01</td></tr></tbody></table><p>优化方案二与未开启优化方案时相比较具有明显的提升，但是相比较与优化方案一的测试结果，优化方案二的测试结果没有优化方案一的提升倍数大，但是避免了之前内核线程oom_reaper处理任务超时的影响，不在内核线程中进行匿名内存和swap内存的回收，而是在对victim进程发出SIGKILL信号的进程的上下文中进行匿名内存、非VM_SHARED内存和swap内存(check_swap_entry)的回收。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Performance comparison of Linux tracing tools</title>
      <link href="2020/12/20/performance_comparison_of_linux_tracing_tools/"/>
      <url>2020/12/20/performance_comparison_of_linux_tracing_tools/</url>
      
        <content type="html"><![CDATA[<h2 id="systrace中ftrace的实现"><a href="#systrace中ftrace的实现" class="headerlink" title="systrace中ftrace的实现"></a>systrace中ftrace的实现</h2><p><img src="/images/performance_comparison_of_linux_tracing_tools/systrace.jpg"></p><h2 id="performance-comparison"><a href="#performance-comparison" class="headerlink" title="performance comparison"></a>performance comparison</h2><p><img src="/images/performance_comparison_of_linux_tracing_tools/performance.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Interface: perf_event_open</title>
      <link href="2020/11/27/perf_event_open/"/>
      <url>2020/11/27/perf_event_open/</url>
      
        <content type="html"><![CDATA[<p>pmu的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* struct pmu - generic performance monitoring unit</span><br><span class="line">*&#x2F;</span><br><span class="line">struct pmu &#123;</span><br><span class="line">   struct list_head        entry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   struct module            *module;</span><br><span class="line">   struct device            *dev;</span><br><span class="line">   const struct attribute_group    **attr_groups;</span><br><span class="line">   const char            *name;</span><br><span class="line">   int                type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * various common per-pmu feature flags</span><br><span class="line">    *&#x2F;</span><br><span class="line">   int                capabilities;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   int * __percpu            pmu_disable_count;</span><br><span class="line">   struct perf_cpu_context * __percpu pmu_cpu_context;</span><br><span class="line">   atomic_t            exclusive_cnt; &#x2F;* &lt; 0: cpu; &gt; 0: tsk *&#x2F;</span><br><span class="line">   int                task_ctx_nr;</span><br><span class="line">   int                hrtimer_interval_ms;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;* number of address filters this PMU can do *&#x2F;</span><br><span class="line">   unsigned int            nr_addr_filters;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Fully disable&#x2F;enable this PMU, can be used to protect from the PMI</span><br><span class="line">    * as well as for lazy&#x2F;batch writing of the MSRs.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   void (*pmu_enable)        (struct pmu *pmu); &#x2F;* optional *&#x2F;</span><br><span class="line">   void (*pmu_disable)        (struct pmu *pmu); &#x2F;* optional *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Try and initialize the event for this PMU.</span><br><span class="line">    *</span><br><span class="line">    * Returns:</span><br><span class="line">    *  -ENOENT    -- @event is not for this PMU</span><br><span class="line">    *</span><br><span class="line">    *  -ENODEV    -- @event is for this PMU but PMU not present</span><br><span class="line">    *  -EBUSY    -- @event is for this PMU but PMU temporarily unavailable</span><br><span class="line">    *  -EINVAL    -- @event is for this PMU but @event is not valid</span><br><span class="line">    *  -EOPNOTSUPP -- @event is for this PMU, @event is valid, but not supported</span><br><span class="line">    *  -EACCESS    -- @event is for this PMU, @event is valid, but no privilidges</span><br><span class="line">    *</span><br><span class="line">    *  0        -- @event is for this PMU and valid</span><br><span class="line">    *</span><br><span class="line">    * Other error return values are allowed.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   int (*event_init)        (struct perf_event *event);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Notification that the event was mapped or unmapped.  Called</span><br><span class="line">    * in the context of the mapping task.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   void (*event_mapped)        (struct perf_event *event, struct mm_struct *mm); &#x2F;* optional *&#x2F;</span><br><span class="line">   void (*event_unmapped)        (struct perf_event *event, struct mm_struct *mm); &#x2F;* optional *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Flags for -&gt;add()&#x2F;-&gt;del()&#x2F; -&gt;start()&#x2F;-&gt;stop(). There are</span><br><span class="line">    * matching hw_perf_event::state flags.</span><br><span class="line">    *&#x2F;</span><br><span class="line">#define PERF_EF_START    0x01        &#x2F;* start the counter when adding    *&#x2F;</span><br><span class="line">#define PERF_EF_RELOAD    0x02        &#x2F;* reload the counter when starting *&#x2F;</span><br><span class="line">#define PERF_EF_UPDATE    0x04        &#x2F;* update the counter when stopping *&#x2F;</span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Adds&#x2F;Removes a counter to&#x2F;from the PMU, can be done inside a</span><br><span class="line">    * transaction, see the -&gt;*_txn() methods.</span><br><span class="line">    *</span><br><span class="line">    * The add&#x2F;del callbacks will reserve all hardware resources required</span><br><span class="line">    * to service the event, this includes any counter constraint</span><br><span class="line">    * scheduling etc.</span><br><span class="line">    *</span><br><span class="line">    * Called with IRQs disabled and the PMU disabled on the CPU the event</span><br><span class="line">    * is on.</span><br><span class="line">    *</span><br><span class="line">    * -&gt;add() called without PERF_EF_START should result in the same state</span><br><span class="line">    *  as -&gt;add() followed by -&gt;stop().</span><br><span class="line">    *</span><br><span class="line">    * -&gt;del() must always PERF_EF_UPDATE stop an event. If it calls</span><br><span class="line">    *  -&gt;stop() that must deal with already being stopped without</span><br><span class="line">    *  PERF_EF_UPDATE.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   int  (*add)            (struct perf_event *event, int flags);</span><br><span class="line">   void (*del)            (struct perf_event *event, int flags);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Starts&#x2F;Stops a counter present on the PMU.</span><br><span class="line">    *</span><br><span class="line">    * The PMI handler should stop the counter when perf_event_overflow()</span><br><span class="line">    * returns !0. -&gt;start() will be used to continue.</span><br><span class="line">    *</span><br><span class="line">    * Also used to change the sample period.</span><br><span class="line">    *</span><br><span class="line">    * Called with IRQs disabled and the PMU disabled on the CPU the event</span><br><span class="line">    * is on -- will be called from NMI context with the PMU generates</span><br><span class="line">    * NMIs.</span><br><span class="line">    *</span><br><span class="line">    * -&gt;stop() with PERF_EF_UPDATE will read the counter and update</span><br><span class="line">    *  period&#x2F;count values like -&gt;read() would.</span><br><span class="line">    *</span><br><span class="line">    * -&gt;start() with PERF_EF_RELOAD will reprogram the the counter</span><br><span class="line">    *  value, must be preceded by a -&gt;stop() with PERF_EF_UPDATE.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   void (*start)            (struct perf_event *event, int flags);</span><br><span class="line">   void (*stop)            (struct perf_event *event, int flags);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Updates the counter value of the event.</span><br><span class="line">    *</span><br><span class="line">    * For sampling capable PMUs this will also update the software period</span><br><span class="line">    * hw_perf_event::period_left field.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   void (*read)            (struct perf_event *event);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Group events scheduling is treated as a transaction, add</span><br><span class="line">    * group events as a whole and perform one schedulability test.</span><br><span class="line">    * If the test fails, roll back the whole group</span><br><span class="line">    *</span><br><span class="line">    * Start the transaction, after this -&gt;add() doesn&#39;t need to</span><br><span class="line">    * do schedulability tests.</span><br><span class="line">    *</span><br><span class="line">    * Optional.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   void (*start_txn)        (struct pmu *pmu, unsigned int txn_flags);</span><br><span class="line">   &#x2F;*</span><br><span class="line">    * If -&gt;start_txn() disabled the -&gt;add() schedulability test</span><br><span class="line">    * then -&gt;commit_txn() is required to perform one. On success</span><br><span class="line">    * the transaction is closed. On error the transaction is kept</span><br><span class="line">    * open until -&gt;cancel_txn() is called.</span><br><span class="line">    *</span><br><span class="line">    * Optional.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   int  (*commit_txn)        (struct pmu *pmu);</span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Will cancel the transaction, assumes -&gt;del() is called</span><br><span class="line">    * for each successful -&gt;add() during the transaction.</span><br><span class="line">    *</span><br><span class="line">    * Optional.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   void (*cancel_txn)        (struct pmu *pmu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Will return the value for perf_event_mmap_page::index for this event,</span><br><span class="line">    * if no implementation is provided it will default to: event-&gt;hw.idx + 1.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   int (*event_idx)        (struct perf_event *event); &#x2F;*optional *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * context-switches callback</span><br><span class="line">    *&#x2F;</span><br><span class="line">   void (*sched_task)        (struct perf_event_context *ctx,</span><br><span class="line">                   bool sched_in);</span><br><span class="line">   &#x2F;*</span><br><span class="line">    * PMU specific data size</span><br><span class="line">    *&#x2F;</span><br><span class="line">   size_t                task_ctx_size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Set up pmu-private data structures for an AUX area</span><br><span class="line">    *&#x2F;</span><br><span class="line">   void *(*setup_aux)        (int cpu, void **pages,</span><br><span class="line">                    int nr_pages, bool overwrite);</span><br><span class="line">                   &#x2F;* optional *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Free pmu-private AUX data structures</span><br><span class="line">    *&#x2F;</span><br><span class="line">   void (*free_aux)        (void *aux); &#x2F;* optional *&#x2F;</span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Validate address range filters: make sure the HW supports the</span><br><span class="line">    * requested configuration and number of filters; return 0 if the</span><br><span class="line">    * supplied filters are valid, -errno otherwise.</span><br><span class="line">    *</span><br><span class="line">    * Runs in the context of the ioctl()ing process and is not serialized</span><br><span class="line">    * with the rest of the PMU callbacks.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   int (*addr_filters_validate)    (struct list_head *filters);</span><br><span class="line">                   &#x2F;* optional *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Synchronize address range filter configuration:</span><br><span class="line">    * translate hw-agnostic filters into hardware configuration in</span><br><span class="line">    * event::hw::addr_filters.</span><br><span class="line">    *</span><br><span class="line">    * Runs as a part of filter sync sequence that is done in -&gt;start()</span><br><span class="line">    * callback by calling perf_event_addr_filters_sync().</span><br><span class="line">    *</span><br><span class="line">    * May (and should) traverse event::addr_filters::list, for which its</span><br><span class="line">    * caller provides necessary serialization.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   void (*addr_filters_sync)    (struct perf_event *event);</span><br><span class="line">                   &#x2F;* optional *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Filter events for PMU-specific reasons.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   int (*filter_match)        (struct perf_event *event); &#x2F;* optional *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>perf_event_open</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* sys_perf_event_open - open a performance event, associate it to a task&#x2F;cpu</span><br><span class="line">*</span><br><span class="line">* @attr_uptr:    event_id type attributes for monitoring&#x2F;sampling</span><br><span class="line">* @pid:        target pid</span><br><span class="line">* @cpu:        target cpu</span><br><span class="line">* @group_fd:        group leader event fd</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">event &#x3D; perf_event_alloc(&amp;attr, cpu, task, group_leader, NULL,</span><br><span class="line">                NULL, NULL, cgroup_fd);</span><br></pre></td></tr></table></figure><p>&nbsp;<br>perf_event_open -&gt; perf_event_alloc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* Allocate and initialize a event structure</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>perf_event的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* struct perf_event - performance event kernel representation:</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>在perf_event_alloc中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct pmu *pmu;</span><br><span class="line">event-&gt;pmu &#x3D; NULL;</span><br><span class="line">pmu &#x3D; NULL;</span><br><span class="line">pmu &#x3D; perf_init_event(event);</span><br></pre></td></tr></table></figure><p>&nbsp;<br>perf_event_alloc -&gt; perf_init_event</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Try parent&#39;s PMU first: *&#x2F;</span><br><span class="line">if (event-&gt;parent &amp;&amp; event-&gt;parent-&gt;pmu)</span><br></pre></td></tr></table></figure><p>如果perf_event存在父类perf_event且有注册的pmu，就直接拿来用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pmu &#x3D; event-&gt;parent-&gt;pmu;</span><br><span class="line">ret &#x3D; perf_try_init_event(pmu, event);</span><br></pre></td></tr></table></figure><p>如果没有的话，要先根据event的种类找一个pmu注册的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pmu &#x3D; idr_find(&amp;pmu_idr, event-&gt;attr.type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct perf_event_attr attr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* Major type: hardware&#x2F;software&#x2F;tracepoint&#x2F;etc.</span><br><span class="line">*&#x2F;</span><br><span class="line">__u32 type;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>idr_find的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* idr_find - return pointer for given id</span><br><span class="line">* @idr: idr handle</span><br><span class="line">* @id: lookup key</span><br><span class="line">*</span><br><span class="line">* Return the pointer given the id it has been registered with.  A %NULL</span><br><span class="line">* return indicates that @id is not valid or you passed %NULL in</span><br><span class="line">* idr_get_new().</span><br><span class="line">*</span><br><span class="line">* This function can be called under rcu_read_lock(), given that the leaf</span><br><span class="line">* pointers lifetimes are correctly managed.</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>perf_init_event -&gt; perf_try_init_event</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event-&gt;pmu &#x3D; pmu;</span><br><span class="line">ret &#x3D; pmu-&gt;event_init(event);</span><br></pre></td></tr></table></figure><p>调用pmu-&gt;event_init<br>&nbsp;<br>在core.c中，pmu是这样注册的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static struct pmu perf_tracepoint &#x3D; &#123;</span><br><span class="line">   .task_ctx_nr    &#x3D; perf_sw_context,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   .event_init    &#x3D; perf_tp_event_init,</span><br><span class="line">   .add        &#x3D; perf_trace_add,</span><br><span class="line">   .del        &#x3D; perf_trace_del,</span><br><span class="line">   .start        &#x3D; perf_swevent_start,</span><br><span class="line">   .stop        &#x3D; perf_swevent_stop,</span><br><span class="line">   .read        &#x3D; perf_swevent_read,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>event_init -&gt; perf_tp_event_init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err &#x3D; perf_trace_init(event);</span><br><span class="line">event-&gt;destroy &#x3D; tp_perf_event_destroy;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>perf_tp_event_init -&gt; perf_trace_init<br>对所有的ftrace_events尝试就行初始化注册<br>&nbsp;<br>perf_trace_init -&gt; perf_trace_event_init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static int perf_trace_event_init(struct trace_event_call *tp_event,</span><br><span class="line">                struct perf_event *p_event)</span><br><span class="line">&#123;</span><br><span class="line">   int ret;</span><br><span class="line"></span><br><span class="line">   ret &#x3D; perf_trace_event_perm(tp_event, p_event);</span><br><span class="line">   if (ret)</span><br><span class="line">       return ret;</span><br><span class="line"></span><br><span class="line">   ret &#x3D; perf_trace_event_reg(tp_event, p_event);</span><br><span class="line">   if (ret)</span><br><span class="line">       return ret;</span><br><span class="line"></span><br><span class="line">   ret &#x3D; perf_trace_event_open(p_event);</span><br><span class="line">   if (ret) &#123;</span><br><span class="line">       perf_trace_event_unreg(p_event);</span><br><span class="line">       return ret;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>perf_trace_event_perm用来就行权限判断<br>&nbsp;<br>perf_trace_event_init -&gt; perf_trace_event_reg<br>初始化trace_event_call上per_cpu的perf_event挂载链表：tp_event-&gt;perf_events 如果perf_event需要接收tracepoint的数据，需要按绑定的cpu挂载到对应的per_cpu链表上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for_each_possible_cpu(cpu)</span><br><span class="line">    INIT_HLIST_HEAD(per_cpu_ptr(list, cpu));</span><br><span class="line">tp_event-&gt;perf_events &#x3D; list;</span><br></pre></td></tr></table></figure><p>通过tp_event-&gt;class-&gt;reg对event就行注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret &#x3D; tp_event-&gt;class-&gt;reg(tp_event, TRACE_REG_PERF_REGISTER, NULL);</span><br></pre></td></tr></table></figure><p>实际上，在对event_class定义时，trace_event_class的reg函数指针就注册为trace_event_reg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static struct trace_event_class __used __refdata event_class_##call &#x3D; &#123; \</span><br><span class="line">   .system            &#x3D; TRACE_SYSTEM_STRING,            \</span><br><span class="line">   .define_fields        &#x3D; trace_event_define_fields_##call,    \</span><br><span class="line">   .fields            &#x3D; LIST_HEAD_INIT(event_class_##call.fields),\</span><br><span class="line">   .raw_init        &#x3D; trace_event_raw_init,            \</span><br><span class="line">   .probe            &#x3D; trace_event_raw_event_##call,        \</span><br><span class="line">   .reg            &#x3D; trace_event_reg,            \</span><br><span class="line">   _TRACE_PERF_INIT(call)                        \</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>reg -&gt; trace_event_reg<br>此时传入的type为TRACE_REG_PERF_REGISTER，将perf_probe探针挂到tracepoint上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">case TRACE_REG_PERF_REGISTER:</span><br><span class="line">   return tracepoint_probe_register(call-&gt;tp, call-&gt;class-&gt;perf_probe, call);</span><br></pre></td></tr></table></figure><p>&nbsp;<br>trace_event_reg -&gt; tracepoint_probe_register</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* tracepoint_probe_register -  Connect a probe to a tracepoint</span><br><span class="line">* @tp: tracepoint</span><br><span class="line">* @probe: probe handler</span><br><span class="line">* @data: tracepoint data</span><br><span class="line">* @prio: priority of this function over other registered functions</span><br><span class="line">*</span><br><span class="line">* Returns 0 if ok, error value on error.</span><br><span class="line">* Note: if @tp is within a module, the caller is responsible for</span><br><span class="line">* unregistering the probe before the module is gone. This can be</span><br><span class="line">* performed either with a tracepoint module going notifier, or from</span><br><span class="line">* within module exit functions.</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>tracepoint_probe_register -&gt; tracepoint_probe_register_prio</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* tracepoint_probe_register -  Connect a probe to a tracepoint</span><br><span class="line">* @tp: tracepoint</span><br><span class="line">* @probe: probe handler</span><br><span class="line">* @data: tracepoint data</span><br><span class="line">* @prio: priority of this function over other registered functions</span><br><span class="line">*</span><br><span class="line">* Returns 0 if ok, error value on error.</span><br><span class="line">* Note: if @tp is within a module, the caller is responsible for</span><br><span class="line">* unregistering the probe before the module is gone. This can be</span><br><span class="line">* performed either with a tracepoint module going notifier, or from</span><br><span class="line">* within module exit functions.</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>tracepoint_probe_register_prio -&gt; tracepoint_add_func</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* Add the probe function to a tracepoint.</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>此时perf_event的回调函数注册到对应的tracepoint上。<br>在使用perf tracepoint event时，随着task的调度，perf才能record每个tracepoint对应的perf_event的启动与停止。<br>所以需要pmu-&gt;add()来进行数据的采集。<br>从perf_event_task_sched_in开始<br>perf_event_task_sched_in -&gt; __perf_event_task_sched_in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* Called from scheduler to add the events of the current task</span><br><span class="line">* with interrupts disabled.</span><br><span class="line">*</span><br><span class="line">* We restore the event value and then enable it.</span><br><span class="line">*</span><br><span class="line">* This does not protect us against NMI, but enable()</span><br><span class="line">* sets the enabled bit in the control field of event _before_</span><br><span class="line">* accessing the event control register. If a NMI hits, then it will</span><br><span class="line">* keep the event running.</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>__perf_event_task_sched_in -&gt; perf_event_context_sched_in -&gt; perf_event_sched_in -&gt; ctx_sched_in<br>先对高优先级的ctx进行调度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">is_active ^&#x3D; ctx-&gt;is_active   </span><br><span class="line">&#x2F;*</span><br><span class="line">* First go through the list and put on any pinned groups</span><br><span class="line">* in order to give them the best chance of going on.</span><br><span class="line">*&#x2F;</span><br><span class="line">if (is_active &amp; EVENT_PINNED)</span><br><span class="line">   ctx_pinned_sched_in(ctx, cpuctx);</span><br><span class="line">&#x2F;* Then walk through the lower prio flexible groups *&#x2F;</span><br><span class="line">if (is_active &amp; EVENT_FLEXIBLE)</span><br><span class="line">   ctx_flexible_sched_in(ctx, cpuctx);</span><br></pre></td></tr></table></figure><p>&nbsp;<br>ctx_sched_in -&gt; ctx_pinned_sched_in/ctx_flexible_sched_in -&gt; group_sched_in -&gt; event_sched_in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perf_pmu_disable(event-&gt;pmu);</span><br><span class="line">if (event-&gt;pmu-&gt;add(event, PERF_EF_START));</span><br><span class="line">perf_pmu_enable(event-&gt;pmu);</span><br></pre></td></tr></table></figure><p>&nbsp;<br>add -&gt; perf_trace_add</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list &#x3D; this_cpu_ptr(pcpu_list);</span><br><span class="line">hlist_add_head_rcu(&amp;p_event-&gt;hlist_entry, list);</span><br><span class="line">return tp_event-&gt;class-&gt;reg(tp_event, TRACE_REG_PERF_ADD, p_event);</span><br></pre></td></tr></table></figure><p>将perf_event加入到tp_event-&gt;perf_events的当前cpu链表中<br>reg -&gt; trace_event_reg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case TRACE_REG_PERF_OPEN:</span><br><span class="line">case TRACE_REG_PERF_CLOSE:</span><br><span class="line">case TRACE_REG_PERF_ADD:</span><br><span class="line">case TRACE_REG_PERF_DEL:</span><br><span class="line">   return 0;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>在DECLARE_EVENT_CLASS时候，已经通过_TRACE_PERF_PROTO(call, PARAMS(proto))和_TRACE_PERF_INIT(call)定义了perf_probe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define _TRACE_PERF_PROTO(call, proto)                    \</span><br><span class="line">   static notrace void                        \</span><br><span class="line">   perf_trace_##call(void *__data, proto);</span><br><span class="line"></span><br><span class="line">#define _TRACE_PERF_INIT(call)                        \</span><br><span class="line">   .perf_probe &#x3D; perf_trace_##call,</span><br></pre></td></tr></table></figure><p>&nbsp;<br>在perf_trace_##call中，perf_trace_run_bpf_submit()负责提交数据给this_cpu_ptr(event_call-&gt;perf_events)链表上等待的perf_event<br>perf_trace_run_bpf_submit -&gt; perf_tp_event<br>raw data结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct perf_raw_record raw &#x3D; &#123;</span><br><span class="line">   .frag &#x3D; &#123;</span><br><span class="line">       .size &#x3D; entry_size,</span><br><span class="line">       .data &#x3D; record,</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把sample数据逐个发送给当前cpu perf_events链表上链接的perf_event<br>如果指定了目标task，还要迭代它的上下文将其数据传送到task上绑定的perf_event<br>&nbsp;<br>perf_tp_event -&gt; perf_swevent_event<br>perf_swevent_event通过local64_add增加event的count<br>判断是否是period模式，根据其设置数据进行上报<br>&nbsp;<br>perf_swevent_event -&gt; perf_swevent_overflow -&gt; __perf_event_overflow</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">READ_ONCE(event-&gt;overflow_handler)(event, data, regs);</span><br></pre></td></tr></table></figure><p>&nbsp;<br>在perf_event_alloc中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (overflow_handler) &#123;</span><br><span class="line">    event-&gt;overflow_handler    &#x3D; overflow_handler;</span><br><span class="line">    event-&gt;overflow_handler_context &#x3D; context;</span><br><span class="line">&#125; else if (is_write_backward(event))&#123;</span><br><span class="line">    event-&gt;overflow_handler &#x3D; perf_event_output_backward;</span><br><span class="line">    event-&gt;overflow_handler_context &#x3D; NULL;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    event-&gt;overflow_handler &#x3D; perf_event_output_forward;</span><br><span class="line">    event-&gt;overflow_handler_context &#x3D; NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>overflow_handler -&gt; perf_event_output_forward/perf_event_output_backward -&gt; __perf_event_output -&gt; perf_output_sample<br>把数据输出到ringbuffer中，根据data-&gt;type来判断要输出那些信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Using ATrace(Android system and app trace events)</title>
      <link href="2020/11/12/using_atrace/"/>
      <url>2020/11/12/using_atrace/</url>
      
        <content type="html"><![CDATA[<h2 id="ATrace是什么"><a href="#ATrace是什么" class="headerlink" title="ATrace是什么"></a>ATrace是什么</h2><p>ATarce(Android system and app trace events)是Android系统和软件的事件追踪器，支持用户空间的系统事件和软件事件，以及内核空间的函数追踪。它支持设置属性来进行用户空间追踪，也可以写入ftrace的sysfs节点进行事件追踪，还能利用function tracer进行内核中大部分函数进行追踪。</p><p>它一方面通过NDK层设置接口给JNI提供API，另一方面又通过zygote在Android内部进程中对属性及时响应，还在通过设置ftrace下的节点属性控制信息输出。</p><h2 id="ATrace流程图"><a href="#ATrace流程图" class="headerlink" title="ATrace流程图"></a>ATrace流程图</h2><p><img src="/images/using_atrace/atrace_2.jpg" alt="atrace_2"></p><h2 id="ATrace信息捕获"><a href="#ATrace信息捕获" class="headerlink" title="ATrace信息捕获"></a>ATrace信息捕获</h2><p>根据atrace.cpp源码可以看出，对于追踪类型的分类依据来源于k_categories结构中定义好的值。k_categories是一个TracingCategory结构体，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct TracingCategory &#123;</span><br><span class="line">    &#x2F;&#x2F; The name identifying the category.</span><br><span class="line">    const char* name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; A longer description of the category.</span><br><span class="line">    const char* longname;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The userland tracing tags that the category enables.</span><br><span class="line">    uint64_t tags;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The fname&#x3D;&#x3D;NULL terminated list of &#x2F;sys&#x2F; files that the category</span><br><span class="line">    &#x2F;&#x2F; enables.</span><br><span class="line">    struct &#123;</span><br><span class="line">        &#x2F;&#x2F; Whether the file must be writable in order to enable the tracing</span><br><span class="line">        &#x2F;&#x2F; category.</span><br><span class="line">        requiredness required;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; The path to the enable file.</span><br><span class="line">        const char* path;</span><br><span class="line">    &#125; sysfiles[MAX_SYS_FILES];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中成员tags能够对用户空间的追踪选项进行标识，sysfiles则提供了某个追踪类别的节点信息。atrace使用参数-k来标识是否启用内核函数追踪。根据参数-k和k_categories可以知道，atrace主要采用如下几种方式来进行追踪。</p><h4 id="1-ATRACE-TAG方式"><a href="#1-ATRACE-TAG方式" class="headerlink" title="1. ATRACE_TAG方式"></a>1. ATRACE_TAG方式</h4><p>ATRACE_TAG方式是atrace的默认方式，使能方法是传入默认的追踪类型。它是只针对用户空间的追踪方式，通过将k_categories中各个非零tags的标识位进行按位或运算后来设置系统属性debug.atrace.tags.enableflags。在Android系统中，zygote进程启动后，通过一系列调用判断ATRACE_TAG的设置和ATRACE_CALL()或ATrace_beginSection的位置，以WRITE_MSG的形式写入atrace_marker_fd，即trace_marker的位置，填充ftrace的ring buffer。具体的时序图如下:</p><p><img src="/images/using_atrace/zygote.jpg" alt="zygote"></p><p><img src="/images/using_atrace/getprop.jpg" alt="getprop"></p><p><img src="/images/using_atrace/atrace_call.jpg" alt="atrace_call"></p><p>在NDK层封装好API后，通过JNI的机制，就可以在java里调用trace。在<code>frameworks/base/core/jni/android_os_Trace.cpp</code>中设置如下:</p><p><img src="/images/using_atrace/jniatrace.png" alt="jniatrace"></p><p>对于ATRACE_TAG来说，java层采取和libcutils相同的方式，采用相同的标志位进行声明，确保分类一致。</p><p><img src="/images/using_atrace/tracetag.jpg" alt="tracetag"></p><p>之后就可以在framework层中轻松的使用trace了，例如:</p><p><img src="/images/using_atrace/framework.png" alt="framework"></p><h4 id="2-appname方式"><a href="#2-appname方式" class="headerlink" title="2. appname方式"></a>2. appname方式</h4><p>appname方式能够对设置的进程名称进行追踪，但可能会导致一系列不可控的返回信息。其使能方式是通过参数-a传入包名来进行设置，然后设置系统属性debug.atrace.app_number和debug.atrace.app，确定追踪的包名的个数和对应的属性，之后也是类似ATRACE_TAG的方式使用libcutils进行追踪。具体的时序图如下：</p><p><img src="/images/using_atrace/appname.jpg" alt="appname"></p><p>appname方式会在进程内部读取/proc/self/cmdline的第一行，然后和系统属性debug.atrace.app进行比对，当匹配成功时代表该进程需要进行app级别的调试追踪，然后设置ATRACE_TAG_APP，</p><h4 id="3-trace-event方式"><a href="#3-trace-event方式" class="headerlink" title="3. trace event方式"></a>3. trace event方式</h4><p>trace event方式是对debugfs中events下的节点使能来进行追踪控制的。通常来说，trace event使用宏TRACE_EVENT()来新增追踪事件。当对应节点被使能后，函数插桩被激活，桩点中的函数被调用时就会被记录下来，将数据通过设置好的filter和trigger存储到ring buffer中，最后通过设置好的format进行格式化输出。</p><p>对于format中每个块来说，filed格式为<code>field:field-type field-name; offset:N; size:N;</code>，如果一个field-name以<code>common_</code>开头的话，说明这个field是公共定义的，在相同的event下都享受这个filed。</p><p>对于event的filter来说，可以通过多种方式就行过滤。比如可以通过表达式语法来指定某些条件下field-name的匹配；也可以直接控制某个event下的所有子系统，此时会根据具体的filter下是否有修改的field来进行修改；还可以利用PID的方式直接对<code>set_event_pid</code>节点进行设置。</p><p>trigger则是用来对event的控制命令进行过滤。它可以控制这个另一个event的开启与关闭当这个event的trigger被激活时，也可以转储堆栈追踪、记录捕获的函数到snapshot中，也能直接控制追踪的开启与关闭。值得注意的是，这些trigger commands都能通过表达式语法来进行更细致的控制，能够直接对每个event定义的<code>TP_STRUCT__entry</code>中的成员来用于条件判断。</p><h4 id="4-内核函数追踪方式"><a href="#4-内核函数追踪方式" class="headerlink" title="4. 内核函数追踪方式"></a>4. 内核函数追踪方式</h4><p>内核函数追踪方式能够对内核中大部分函数(不包括notrace、inline、某些特殊函数)进行追踪，其原理是ftrace中的dynamic fucntion tracer。内核函数追踪的使能方式是通过参数-k来设置要追踪哪几个函数。dynamic fucntion tracer有两种方式，一种是function的方式，另一种是function_graph的方式。对于dynamic fucntion tracer来说，它可以把不需要追踪的函数入口处指令<code>bl _mcount</code>替换成<code>nop</code>，这样基本对性能无影响，对需要追踪的函数替换入口处指令<code>bl _mcount</code>替换为<code>ftrace_caller</code>。对于dynamic function_graph tracer来说，则需要对函数的入口和出口同时插桩，获得函数的执行时间。需要注意的是，atrace默认的内核函数采用function_graph的方式进行，而修改后的atrace则可以采用function的方式。</p><h2 id="function与function-graph的性能比较"><a href="#function与function-graph的性能比较" class="headerlink" title="function与function_graph的性能比较"></a>function与function_graph的性能比较</h2><p><img src="/images/using_atrace/compare.png" alt="compare"></p><p>根据实际测试比较可知，在使用function和function_graph两种tracer时候，在其他参数一致的情况下，两种方式的追踪消耗时间实际上是差不多的，而且内存占用也差不多。但是function tracer比function_graph tracer的cpu消耗多了40%，而且与系统追踪相比，内核追踪的cpu消耗极大。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>What We Talk About When We Talk About ChrDev</title>
      <link href="2020/09/17/what_we_talk_about_when_we_talk_about_chrdev/"/>
      <url>2020/09/17/what_we_talk_about_when_we_talk_about_chrdev/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文内核版本主要基于4.14，少部分会与5.8.7版本进行比较。</p></blockquote><h2 id="什么是设备驱动程序"><a href="#什么是设备驱动程序" class="headerlink" title="什么是设备驱动程序"></a>什么是设备驱动程序</h2><p>Linux内核拥有庞大而复杂的代码，通常内核黑客(kernel hacker)需要找到一个进入内核的方法，设备驱动程序就是其中一个选择。设备驱动程序作为应用软件和硬件之间的纽带，软件上层调用API接口，通过中间的设备驱动程序驱使底层硬件设备进行具体工作。设备驱动程序通常不会提供具体的策略，而是处理硬件适用的问题，用以展现设备的特性。</p><h2 id="设备驱动包括哪些"><a href="#设备驱动包括哪些" class="headerlink" title="设备驱动包括哪些"></a>设备驱动包括哪些</h2><p>作为不太严格的划分，Linux系统设备通常分为三类：字符设备、块设备和网络设备。字符设备和块设备的区别在于内核传递数据的方式不一致，两者都是通过文件系统节点来访问。当然，Linux还有其他类型的设备用以实现其他的任务，但总的来看，内核可以通过动态的加载内核模块实现具体的功能。</p><p>使用<code>ll /dev</code>查看设备文件的具体信息：</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200917112623.png"></p><p>可以看到，文件属性字段的第一个字母直接表明了该设备的种类，字母c代表字符设备文件，字母b代表块设备文件。同时，原本标识文件长度的地方现在变为了两个编号，这是因为Linux内核采用主设备号和次设备号标识一个确定的设备驱动程序。一个驱动程序可以分配多个主设备号，同一个设备驱动程序可以管理多个同样类型的设备，通过次设备号来标识。</p><p>下文主要讨论字符设备。</p><h2 id="上层应用与底层驱动"><a href="#上层应用与底层驱动" class="headerlink" title="上层应用与底层驱动"></a>上层应用与底层驱动</h2><p>在Linux中，由于“一切皆文件”的性质，对于硬件设备的操作在应用中就被视作了文件的操作，每个文件被一个struct inode结构体来描述，而对于字符设备驱动的inode来说，其中包含一个struct cdev结构体记录字符设备。当open函数打开设备文件时，根据inode结构中的设备信息可以判断该设备文件是字符设备还是块设备并分配一个struct file，之后根据inode中dev_t类型的设备号找到对应的驱动程序。同时将struct cdev的内存空间首地址存储到inode中的i_cdev成员中，将struct cdev的接口函数操作地址存储到file结构体的f_op成员中。最终VFS层会给open函数返回一个文件描述符fd(与struct file对应)，其他函数就可以根据这个文件描述符fd找到struct file，并进行对应字符设备的函数操作。</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/chrdev12.jpg"></p><p>其中在VFS层中的操作过程会在下面分析。</p><h2 id="设备号及分配"><a href="#设备号及分配" class="headerlink" title="设备号及分配"></a>设备号及分配</h2><p>对于字符设备来说有两种方法分配设备号：mknod和使用函数在驱动程序中创建。而在使用函数在驱动程序中创建时，通常有两个选择，静态分配(<code>register_chrdev_region()</code>)和动态分配(<code>alloc_chrdev_region()</code>)。在分配成功时返回0，失败时返回负的错误码。还可以使用<code>include/linux/kdev_t.h</code>中特定的宏来进行设备号相关操作，<code>MAJOR(dev_t dev)</code>可以获取主设备号，<code>MINOR(dev_t dev)</code>可以获取次设备号，<code>MKDEV(int major, int minor)</code>可以将一对主次设备号转换为dev_t类型的设备编号。</p><p>对于内核开发者来说，不能向自己的设备驱动程序随便定义设备号。对于内核源码的标准发行版，在<code>Documentation/admin-guide/devices.txt</code>下可以看到常用设备分配的设备号，在进行静态分配设备号时需要避开防止冲突。</p><p>动态注册设备号允许在用户层来创建，当内核检测到设备时，通过udevd守护进程机制，借助udevd规则创建内核对象进行设备管理，借助tmpfs在/dev中创建对应项，由于tmpfs的特性，设备节点不再是持久的，在系统关机重启后会消失。</p><p><code>register_chrdev_region()</code>和<code>alloc_chrdev_region()</code>函数都在<code>fs/char_dev.c</code>中定义。静态分配时，<code>register_chrdev_region()</code>通过传入的dev_t设备编号和设备数确定注册的范围，并在这个范围中遍历注册字符设备，注册失败则调用<code>__unregister_chrdev_region()</code>来卸载字符设备并使用kfree来释放kzalloc申请的空间。对于<code>__unregister_chrdev_region()</code>来说，它多了一个baseminor参数来确定要求注册的次设备号范围的第一个序号，同时在内部调用<code>__register_chrdev_region()</code>时所传入的major值为0，这样<code>__register_chrdev_region()</code>判断major等于0时，通过<code>find_dynamic_major()</code>函数从散列表的末尾表项开始继续向后寻找一个与尚未使用的主设备号对应的空冲突表。</p><p>如果观察<code>register_chrdev_region()</code>和<code>alloc_chrdev_region()</code>的异常判断和返回值，可以发现它们都使用了两个宏：<code>IS_ERR()</code>和<code>PTR_ERR()</code>，这是两个很有趣的实现。</p><p>在<code>include/linux/err.h</code>中实现了一个宏<code>#define IS_ERR_VALUE(x) unlikely((unsigned long)(void *)(x) &gt;= (unsigned long)-MAX_ERRNO)</code>来判断是否是错误码，并且这个宏对不同的体系架构具有普适性(a per-architecture thing)。Linux内核中，错误码都是以负数的形式存在，由<code>#define MAX_ERRNO 4095</code>可知，错误码的范围为[-4095,-1]。在unsigned long下面，-4095转换为0xFFFFF001，-1转换为0xFFFFFFFF，所以上述范围就变为了[0xFFFFF001,0xFFFFFFFF]。</p><p>Linux上用户空间和内核空间是被分开的，在内核空间中操作系统划分出一块保留区域，这个范围内的内核地址是不能被分配的。</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/chrdev13.jpg"></p><p>由上图可知这块保留区域在内存的中的地址恰好就是之前unsigned long转换后错误码的范围。<code>IS_ERR()</code>传入的是一个指针类型的参数，它直接判断这个传递的指针是否是在有效的内存地址，此时如果传入的是转换为指针类型的错误码就会判断为保留地址，即得出这个传入的指针不是分配的内存地址、而是被转换为指针类型的错误码的结论。之后<code>PTR_ERR()</code>直接将这个指针转换为long类型的错误码值并返回。</p><p>通过利用保留区域和MAX_ERRNO，成功将有效的内存地址和错误码区分开来。</p><h2 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h2><p>字符设备作为设备文件，通过inode中的成员i_cdev直接指向cdev结构体。在<code>include/linux/cdev.h</code>中可以看见cdev的原型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct cdev &#123;</span><br><span class="line">struct kobject kobj;</span><br><span class="line">struct module *owner;</span><br><span class="line">const struct file_operations *ops;</span><br><span class="line">struct list_head list;</span><br><span class="line">dev_t dev;</span><br><span class="line">unsigned int count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>kobject是内核设备模型的核心部分，提供了引用计数、父指针等字段。当初始化之后，kobject的引用计数设为1，如果引用计数不清零，则该对象就一直保持在内存中。当引用计数为零时，对象可以被撤销，相关内存也可以被释放。通过<code>kref_get()</code>和<code>kref_put()</code>可以增加和减少引用计数。</p><p>当kobject嵌入cdev中时，cdev结构体成为对象模型层次架构中的一部分，使得cdev能拥有<code>cdev-&gt;kobj.parent</code>等指针操作。owner表示驱动程序模块所有者字段。list作为一个链表来包含设备特殊文件的inode。dev是dev_t类型的设备号。count用来记录该设备下面关联的次设备号的数量。ops作为最重要的的成员，是一个file_operations结构体，内核通过<code>cdev-&gt;ops</code>直接访问该设备的文件操作。</p><p>file_operations结构包含了大量的函数指针，对于每一个所要设置的方法，对应的每个字段都应该指向驱动程序中实现对应操作的函数，而对于不需要实现的方法可以将其设置为NULL。在早期，字符设备的文件操作定义很含糊，在标准上只有一个open操作来向结构传入已经打开的设备的函数指针，从而来进一步操作字符设备。如今字符设备驱动的文件操作越来越多，包含了各种对于设备属性的抽象。除开我们在设备驱动程序中自己编写的文件操作，其实内核本身也提供了预留的文件操作，它们通常以<code>generic_file_</code>作为函数名的开头，例如<code>generic_file_open()</code>、<code>generic_file_read_iter()</code>、<code>generic_file_llseek()</code>等，这些通用实现为文件操作提供了便利。</p><p>由于现实中字符设备驱动的复杂性和多样的设计需求，struct cdev通常是作为一个内嵌的成员变量放在实际的字符设备的数据结构中的。</p><p>在对设备节点分配完成后，在内核对设备进行操作之前，由于内核使用struct cdev结构来表示字符设备，因此需要进行cdev的分配和初始化。由于我们将cdev嵌入到自己的数据结构中，所以通过<code>cdev_init()</code>初始化已经分配到的结构并绑定已经定义的file_operations。之后调用<code>cdev_add()</code>向内核添加该字符设备，同样，它也是成功返回0，失败返回负的错误码。当需要移除字符设备时，通过<code>cdev_del()</code>进行移除。</p><p>那么对于一个最基本的read文件操作，是怎么通过用户空间的C库API传递到底层文件设备进行读取的呢？让我们先从VFS入手。</p><h2 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h2><p>VFS全称Virtual File System，是内核子系统，为用户空间提供文件和文件系统相关的接口。要理解虚拟文件系统，应先看看Linux下的文件系统。VFS的主要代码位于<code>include\linux\fs.h</code>。Linux秉承“一切皆文件”的理念，整个系统由成千上万的文件构成，使用目录结构来管理组织存储的数据。Linux支持不同的文件系统，如Ext2、Ext4、XFS、Btrfs、VFAT等，然而不同的文件系统具有非常大的特性差异，为了将这些具体特性与上层应用层和下层内核层分离开来，需要提供一层关键的文件处理机制，这就是VFS。VFS向下对底层独立的文件系统导出接口进行抽象，向上提供用户空间到系统调用访问文件系统的功能。</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/chrdev11.jpg"></p><p>对于每个文件系统的实现来说，它们导出一组通用接口提供给VFS。对于块设备文件来说，使用页缓存、块缓存等缓冲区用来缓存文件系统与块设备层之间的请求。VFS采取一种大而全的思想，它提供了一种结构模型，包含了文件系统所具备的全部组件，然后通过函数指针来进行定义。</p><p>对于用户空间和内核空间来说，两者之间在处理文件时面向的对象是不一样的。对于用户程序来说，一个文件由一个文件描述符标识，文件描述符由内核分配，只在一个进程内部有效。对于内核来说，则是通过inode来描述文件的元数据和指向文件数据的指针。inode_hashtable支持根据inode编号和超级块快速访问inode。</p><p>我们先从4个主要的对象类型来分析VFS：super_operations(超级块对象)、inode_operations(索引节点对象)、dentry_operations(目录项对象)、file_operations(文件对象)。每种对象作为一个结构体指针来实现，每个结构体里面包含对应的指向其文件操作的函数指针。这4种对象由4个结构体来声明：super_block、inode、dentry、file。</p><p>各类文件系统都要实现超级块对象，它用来描述整个文件系统的信息，包括设备标识符、文件系统子类型、文件大小上限、超级块方法、挂载标志等。索引节点对象包括了内核操作文件及目录时的信息，如散列表、访问权限、引用计数、实际设备标识符、相关的超级块、相关的地址映射等。</p><p>VFS把目录当作文件来看待，所以目录项能用来表示具体文件的位置，并反映了文件系统的树状关系。目录项对象没有对应的硬盘对象结构，因此也不存在是否被修改的标志。目录项对象具有4种状态：空闲、被使用、未被使用、负状态。处于空闲状态的目录项对象不包括有效的信息，且还没有被VFS使用。被使用状态对应一个有效的inode，且d_count为正值。未被使用状态也对应一个有效的inode，但d_count为0，该目录项不会快速撤销，有利于之后继续使用。负状态的目录项没有对应的有效inode，虽然索引节点已经被删除，但是目录项还是被保留。dentry结构不仅易于处理文件系统，还能通过dcache提高系统性能。当访问一个路径时，如果能在目录项缓存中找到该路径名，就能节约大量时间，就算没有找到该路径名，也能将其解析之后放入缓存以便以后快速查找。由于文件系统的特性，文件访问通常是具有空间及时间的局部性，程序很有可能会在同一个目录下访问多个文件或者某个文件会被多次访问，此时由于dcache的存在，其路径命中几率会大大增加。</p><p>文件对象表示进程打开的文件在其内存中的表示，用于搭建进程和磁盘上的文件的对应关系。由于多个进程可能同时操作同一个文件，因此一个文件可能存在多个对应的文件对象，但这个文件对应的inode和dentry应该是唯一的。</p><p>除了4大文件对象外，还有其他很多与VFS相关的数据结构如vfsmount(表示文件系统的安装点)、file_system_type(描述文件系统功能结构)、fiemap_extent(基于extent存储的数据结构)等。</p><p>那么VFS的这些文件对象如何和进程关联到一起？主要是下面这3种数据结构：files_struct、fs_struct、namespace。文件描述符fd是用来描述打开的文件的，每个进程用一个files_struct结构来记录文件描述符的使用情况，这个files_struct结构称为用户打开文件表，它是进程的私有数据。fs_struct由进程描述符的fs指向，包括了文件系统与进程相关的信息，其中count作为共享同一fs_struct的进程数目，同时用dentry来表示根目录、当前目录等。namespace由进程描述符的mmt_namespace指向，通常来说内核使用的是单进程命名空间。</p><p>一个文件系统对应一个超级块和一个vfsmount。超级块中的s_type指向具体的file_system_type，具体的文件系统通过fs_supers链接具有同一种文件类型的超级块，同一种文件系统类型的超级块由s_instances进行链接。之后进程通过task_struct中的files找到files_struct结构，其中具有成员文件描述符数组fd_array，也就是文件对象数组的索引值。文件对象通过域f_dentry找到d_inode对应的索引节点，建立起文件对象与进程的关联。</p><h2 id="从read出发"><a href="#从read出发" class="headerlink" title="从read出发"></a>从read出发</h2><p>在了解VFS之后，我们回过头来看看用户空间的read到底是怎样读取字符设备的。</p><p>假如现在已经实现了一个简单的字符设备驱动，且通过模块的方式加载了驱动，并赋予设备<code>/dev/dev_fifo0</code>相应的权限。编写了一个测试文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> key_val[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/dev_fifo0&quot;</span>, O_RDWR);</span><br><span class="line">    read(fd, &amp;key_val, <span class="number">64</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该测试程序直接调用read系统函数，函数原型在<code>&lt;unistd.h&gt;</code>中定义如下<br><code>ssize_t read (int __fd, void *__buf, size_t __nbytes)</code><br>运行<code>$ man 2 read</code>了解函数相关信息<br>对应的三个参数为文件描述符、缓冲区起始地址、字节数。根据描述，在支持查找的文件上，读取操作从文件偏移量f_pos开始，以读取的字节数nbytes递增，若文件偏移量等于或大于文件结尾，则停止read。当读取完成所有字节数则返回0，如果返回一个比字节数小的正值则表示读取成功但可能遇到EOF、管道关闭或信号中断，如果读取错误则返回负的错误码。<br>由于使用系统函数，所有它通过系统调用执行陷入指令切换到内核态。为了追踪这个系统函数，我们需要对可执行文件进行反编译来分析汇编文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-gcc -static -g test.c -o test</span><br><span class="line">$ arm-linux-gnueabihf-objdump -D -S test &gt; test.s</span><br></pre></td></tr></table></figure><p>查看汇编代码：</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200917095943.png"></p><p>在main中可以看到，当运行到<code>read(fd, &amp;key_val, 64);</code>时，通过子程序跳转bl跳转到<code>__libc_read</code>。</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200917100022.png"></p><p>之后在<code>__libc_read</code>中，mov.w指令将立即数3传给16位的ip指令指针寄存器，在下一条指令通过bl跳转到<code>__libc_do_syscall</code>。</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200917100203.png"></p><p>在<code>__libc_do_syscall</code>中，mov指令将ip指令指针寄存器传给r7寄存器，然后在下一条指令中用svc系统调用指令转到内核空间中。此处的svc就是ARM汇编中swi的更新替代指令，在发生软中断后直接跳转到异常向量表处。</p><p>在<code>arch/arm/kernel/entry-common.S</code>里可以看到swi的入口<code>ENTRY(vector_swi)</code>。在这下面我们可以看到一段注释<code>Pure EABI user space always put syscall number into scno (r7).</code></p><h2 id="OABI和EABI"><a href="#OABI和EABI" class="headerlink" title="OABI和EABI"></a>OABI和EABI</h2><p>ABI，全称application binary interface，应用程序二进制接口，它使得两个二进制程序模块能够互相兼容。OABI全称old application binary interface，EABI全称embedded application binary interface，两者都是基于ARM平台来讲的。OABI作为ARM系列的第一个ABI，它假设了一个具有浮点运算单元的ARM平台，然而这在没有FPU的机器上会一直请求通信引发内核异常。同时，浮点计算效率也不高。EABI解决了上述问题，优化了嵌入式系统中有限资源内的性能，其浮点性能比OABI高了10倍。</p><p>内核对于OABI和EABI给出了两个system call table，可在<code>arch/arm/include/generated/calls-oabi.S</code>和<code>arch/arm/include/generated/calls-eabi.S</code>找到它们。</p><p>通常来说，可以在make menuconfig中对OABI和EABI进行配置。如果想查看经过某个工具链编译之后的可执行文件采取哪一种配置，可以通过下面的指令进行判断：<br><code>$ readelf -h [file]</code></p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200917095739.png"></p><p>可以看到，在经过arm-linux-gnueabihf-gcc工具链编译之后可执行文件的ABI配置为<code>Version5 EABI, hard-float ABI</code>。</p><h2 id="syscall-table"><a href="#syscall-table" class="headerlink" title="syscall table"></a>syscall table</h2><p>现在回到<code>entry-common.S</code>。<br>通过<code>addne scno, r7,</code>，scno成为了寄存器r7的别名，其值为系统调用号3，<code>adr tbl, sys_call_table</code>读取系统调用表的地址给tbl。</p><p>之后先用对CONFIG_AEABI进行判断决定查找<code>calls-eabi.S</code>还是<code>calls-oabi.S</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_AEABI</span><br><span class="line">#include &lt;calls-eabi.S&gt;</span><br><span class="line">#else</span><br><span class="line">#include &lt;calls-oabi.S&gt;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>最终通过<code>ldrlo pc, [tbl, scno, lsl #2]</code>来调用需求的系统调用。由于<code>__NR_OABI_SYSCALL_BASE</code>是0，所以scno中的值还是为系统调用号3，<code>lsl #2</code>左移两位乘4，tbl为系统调用表sys_call_table的基地址。<code>calls-eabi.S</code>中每个系统调用标号占用4个字节(NATIVE)，所以在基地址上加系统调用号3乘4的值，就可以直接跳入执行<code>sys_read</code>。</p><p><code>sys_read</code>在哪呢？我们在<code>fs/read_write.c</code>中可以找到它的定义：<code>SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)</code>。</p><h2 id="宏定义的艺术"><a href="#宏定义的艺术" class="headerlink" title="宏定义的艺术"></a>宏定义的艺术</h2><p>SYSCALL_DEFINE3作为一个明显的宏，让我们追根溯源一下看看它到底如何展开。先从<code>include/linux/syscalls.h</code>看起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span><br></pre></td></tr></table></figure><p>其中省略号代表可变部分，双#进行分割链接，单#将参数转为字符串。此时宏被展开为<code>SYSCALL_DEFINEx(3, _read, __VA_ARGS__)</code>。<br>根据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define SYSCALL_DEFINEx(x, sname, ...)\</span><br><span class="line">SYSCALL_METADATA(sname, x, __VA_ARGS__)\</span><br><span class="line">__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span><br></pre></td></tr></table></figure><p>此时宏被展开为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_METADATA(_read, 3, __VA_ARGS__)\</span><br><span class="line">__SYSCALL_DEFINEx(3, _read, __VA_ARGS__)</span><br></pre></td></tr></table></figure><p>为了后面高效率的分析宏展开，我们假设此时CONFIG_FTRACE_SYSCALLS未定义。根据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define __SYSCALL_DEFINEx(x, name, ...)\</span><br><span class="line">asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))\</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可将之前的宏展开为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_read(__MAP(3,__SC_DECL,__VA_ARGS__))</span><br></pre></td></tr></table></figure><p>同时根据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define __MAP0(m,...)</span><br><span class="line">#define __MAP1(m,t,a) m(t,a)</span><br><span class="line">#define __MAP2(m,t,a,...) m(t,a), __MAP1(m,__VA_ARGS__)</span><br><span class="line">#define __MAP3(m,t,a,...) m(t,a), __MAP2(m,__VA_ARGS__)</span><br><span class="line">#define __MAP4(m,t,a,...) m(t,a), __MAP3(m,__VA_ARGS__)</span><br><span class="line">#define __MAP5(m,t,a,...) m(t,a), __MAP4(m,__VA_ARGS__)</span><br><span class="line">#define __MAP6(m,t,a,...) m(t,a), __MAP5(m,__VA_ARGS__)</span><br><span class="line">#define __MAP(n,...) __MAP##n(__VA_ARGS__)</span><br><span class="line">#define __SC_DECL(t, a)t a</span><br></pre></td></tr></table></figure><p>最终将宏展开为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_read(unsigned int fd, char __user *buf, size_t count);</span><br></pre></td></tr></table></figure><p>这就是系统调用sys_read的原样。经过这些宏嵌套、宏展开，我们可以知道SYSCALL_DEFINE后面所带的数字就是参数的个数n，其内部第一个参数为系统调用名字的后半部分，之后紧跟n对系统调用参数类型及名称。</p><p>为什么要使用如此多的宏定义而不是采取直接展开的方式呢？主要是因为在以前旧版本的内核中，对于不同体系架构的平台来讲，在用户空间里要将系统调用的32位参数在64位寄存器中进行正确的符号扩展，但由于某些平台的原因导致这个扩展可能失败，访问到错误的地址空间或产生其他异常，导致系统崩溃。</p><p>于是内核增加了宏展开将所有参数转换为64位long类型，在去为所需的类型的、进行转换，避免有符号、无符号之间的错误。</p><p>宏的艺术不止于此，例如在<code>include/linux/build_bug.h</code>中有更精彩的实现。</p><h2 id="read之后"><a href="#read之后" class="headerlink" title="read之后"></a>read之后</h2><p>把视线切换回到<code>fs/read_write.c</code>，可以发现在sys_read中有一个重要的函数<code>vfs_read()</code>。在内核版本5.8.7中多了一层ksys_read。<br><code>vfs_read()</code>原型如下：<br><code>ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)</code><br>sys_read先通过<code>file_pos_read()</code>读取file的f_pos，即文件读写位置，最终向<code>vfs_read()</code>传入file结构、用户空间缓存、读取字节长度、文件读取位置。在确认读写区域有效及读写长度在范围内之后，执行双下划线的底层调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ssize_t __vfs_read(struct file *file, char __user *buf, size_t count,</span><br><span class="line">   loff_t *pos)</span><br><span class="line">&#123;</span><br><span class="line">if (file-&gt;f_op-&gt;read)</span><br><span class="line">return file-&gt;f_op-&gt;read(file, buf, count, pos);</span><br><span class="line">else if (file-&gt;f_op-&gt;read_iter)</span><br><span class="line">return new_sync_read(file, buf, count, pos);</span><br><span class="line">else</span><br><span class="line">return -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合之前在VFS的信息，可以知道，file直接找到成员f_op，即一个file_operations对象。通过f_op直接找到字符设备中的设备读取方法，实现字符设备驱动中的设备读写。读写成功后，函数<code>fsnotify_access()</code>就能通知文件被读取，<code>add_rchar()</code>增加当前进程读取字节数，然后通过<code>inc_syscr()</code>增加当前进程系统调用次数。</p><p>就经过这样一个流程，用户空间的read就与内核空间的字符设备read连结在一起。</p><h2 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h2><p>read与fread有什么不同？系统调用是面向底层的，直接通向操作系统内部的接口，用户态通过系统调用利用软中断切换到内核态，在内核中通过调用内核相关函数实现相应功能。而库函数通常是在用户空间地址执行的，通过将API进行封装和整合， 面向复杂情况下的应用开发。由于大部分库函数并不使用系统调用，不会产生内核上下文切换，因此库函数的效率远远大于系统调用。即使在某些库函数中使用到系统调用，但由于库函数采取缓冲区等措施，因此也比本身系统调用的性能高。</p><h2 id="GOT和PLT"><a href="#GOT和PLT" class="headerlink" title="GOT和PLT"></a>GOT和PLT</h2><p>当我们使用x86_64-linux-gcc动态编译时，与静态编译有什么不同？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g test.c</span><br><span class="line">$ objdump -D -S a.out &gt; objdump.s</span><br></pre></td></tr></table></figure><p>查看汇编代码，可以在main里得到如下信息：</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918102441.png"></p><p>程序跳转为地址为0x10a0的<code>read@plt</code>。</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918102517.png"></p><p>可以看出，通过<code>4c0: e5bcfb00 ldr pc, [ip, #2816]!;</code>，将ip寄存器值加2816偏移量读入程序计数器，并将新地址ip+2816写入中断优先寄存器，进入中断。</p><p>使用<code>$ objdump -R a.out</code>得出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a.out:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000003da0 R_X86_64_RELATIVE  *ABS*+0x00000000000011a0</span><br><span class="line">0000000000003da8 R_X86_64_RELATIVE  *ABS*+0x0000000000001160</span><br><span class="line">0000000000004008 R_X86_64_RELATIVE  *ABS*+0x0000000000004008</span><br><span class="line">0000000000003fd8 R_X86_64_GLOB_DAT  _ITM_deregisterTMCloneTable</span><br><span class="line">0000000000003fe0 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.5</span><br><span class="line">0000000000003fe8 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line">0000000000003ff0 R_X86_64_GLOB_DAT  _ITM_registerTMCloneTable</span><br><span class="line">0000000000003ff8 R_X86_64_GLOB_DAT  __cxa_finalize@GLIBC_2.2.5</span><br><span class="line">0000000000003fb8 R_X86_64_JUMP_SLOT  __stack_chk_fail@GLIBC_2.4</span><br><span class="line">0000000000003fc0 R_X86_64_JUMP_SLOT  close@GLIBC_2.2.5</span><br><span class="line">0000000000003fc8 R_X86_64_JUMP_SLOT  read@GLIBC_2.2.5</span><br><span class="line">0000000000003fd0 R_X86_64_JUMP_SLOT  open@GLIBC_2.2.5</span><br></pre></td></tr></table></figure><p><code>read@GLIBC_2.2.5</code>的绝对地址为0x3fc8。用gdb调试追踪一下read。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ (gdb) x&#x2F;8x 0x3fc8</span><br><span class="line">$ (gdb) disassemble 0x00001050</span><br><span class="line">$ (gdb) disassemble 0x00001060</span><br><span class="line">$ (gdb) disassemble 0x00000000</span><br></pre></td></tr></table></figure><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918105016.png"></p><p>可以看到没有加载符号表，找不到包含指定地址的函数。进入gdb，将断点设置为main，查看共享库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ (gdb) info sharedlibrary</span><br></pre></td></tr></table></figure><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918105445.png"></p><p>可以看见提示说共享库缺少调试信息。根据from的地址增加so文件的符号表，增加elf的源路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ (gdb) add-symbol-file &#x2F;usr&#x2F;lib&#x2F;debug&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.31.so 0x00007ffff7fd0100</span><br><span class="line">$ (gdb) add-symbol-file &#x2F;usr&#x2F;lib&#x2F;debug&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.31.so 0x00007ffff7de9630</span><br><span class="line">$ (gdb) dir ~&#x2F;glibc&#x2F;glibc-2.31&#x2F;elf&#x2F;</span><br></pre></td></tr></table></figure><p>此时再次查看<code>read@plt</code></p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918110222.png"></p><p>继续查看jmpq的完整地址，查看其在符号表中的对应信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ (gdb) x&#x2F;a 0x555555557fc8</span><br><span class="line">$ (gdb) info symbol 0x7ffff7ed4fa0</span><br></pre></td></tr></table></figure><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918111050.png"></p><p>发现能在so的text section中找到，此时程序运行到read的动态链接就能完成。整个共享库的地址翻译，离不开GOT和PLT。</p><p>PLT全称Procedure Link Table(过程链接表)，GOT全称Global Offset Table(全局偏移表)，两者在代码共享及动态库上扮演着重要的角色。在二进制文件中，有一个叫relocations的东西，它能够在工具链静态链接时填充或者在运行时动态链接时填充。它在二进制文件中的作用就是确定某个符号的值，然后将这个符号的值写到某个偏移地址处。</p><p>使用readelf查看可执行文件：</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918112553.png"></p><p>可以看到在<code>.rela.plt</code>的section下，read的符号值为0，存在一个偏移地址为<code>0x000000003fc8</code>，如果使用gdb查看这个位置的机器码的话，会得到下面的结果：</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/20200918113505.png"></p><p>可以看到从offset 0x2位置开始，寄存器rax的值是未确定的，此时对于%al来说，只能以一个0x00作为偏移，来读取此处内存地址的内容。然而实际上，这个寄存器的偏移地址会在链接后进行补全，最后形成真正的地址偏移。在链接阶段，编译器如果发现有代码定义在动态库，链接器会生成一小段额外代码取代原来的地址进行链接重定位，从而进行运行时的重定位。此时PLT将这个区域进行翻译，实现对另一个地址的跳转，之后通过GOT找到so中真正的地址。ELF将GOT拆分为.got和.got.plt，将PLT拆分为.plt和.plt.got，前者保存全局变量引用的地址，后者保存函数引用的地址，在ELF信息中都能看见。而对于.rela来说，.rela.dyn包含relocations动态段的填充地址，.rela.plt包含relocations的plt的偏移量，通过偏移量来找到GOT表项的地址。</p><p>PLT表结构第一项为公共表项，下面是每个动态库函数有一项，并从对应的GOT表项中读取目标函数地址。GOT表前三项为.dyn段地址、link_map数据结构地址和<code>_dl_runtime_resolve</code>函数地址，在动态链接时进行填充。进程加载后，PLT指向不变，动态链接器在ELF的.dynamic段里面找到GOT的地址，当外部函数被调用时才执行重定位。</p><p>GOT还实现了延迟重定位的功能，确保在动态库函数被调用时才作解析，还能获取重定位是否完成的标志，这就是PLT stub实现的延迟绑定技术(lazy binding)。Linux还分类了公共函数，增加.plt的公共入口，避免PLT指令过多。</p><h2 id="回到read"><a href="#回到read" class="headerlink" title="回到read"></a>回到read</h2><p>了解了PLT和GOT之后，动态库的链接也不再那么神秘。如果把目光重新放回read，可能会发现一个函数：<code>new_sync_read()</code>。在<code>__vfs_read()</code>里面，通过对file成员f_op的文件操作函数判断，f_op有read就走read，f_op有read_iter就走<code>new_sync_read()</code>。如果我们查看<code>fs/ext4/file.c</code>、<code>fs/btrfs/file.c</code>中file_operations结构的定义，可以发现在Ext4、Btrfs这些文件系统都不再使用read，取而代之的是read_iter。</p><p>在剖析read_iter之前，先来看下这3个结构：iovec、kiocb、iov_iter。iovec定义在<code>include/uapi/linux/uio.h</code>中，是POSIX标准1003.1g定义的，需要表示io向量的基址和大小。iov_iter定义在<code>include/linux/uio.h</code>中，作为iovec结构的迭代器，处理用户空间提供的数据缓冲区，普遍用于内存管理和文件系统管理。kiocb定义在<code>include/linux/fs.h</code>中，表示kernel io control block，用来记录io操作的完成状态。在<code>new_sync_read()</code>中，先调用<code>init_sync_kiocb()</code>初始化内核io控制块，其中通过<code>iocb_flags()</code>设置状态。此时对于这个判断通常分为O_DIRECT和使用缓存，用<code>io_is_direct()</code>判断，O_DIRECT绕过内核缓存模式，直接进行磁盘的读写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline bool io_is_direct(struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">return (filp-&gt;f_flags &amp; O_DIRECT) || (filp-&gt;f_mapping-&gt;host-&gt;i_flags &amp; S_DAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内核io控制块初始化之后，将传入的读写地址赋给kiocb，调用<code>iov_iter_init()</code>初始化iovec迭代器。iovec中存放着用户空间传入的数据和长度，使用iov_iter减少了内核在数据缓冲区中出错的可能，通过计数、copy等原子操作修改数据。最终，<code>call_read_iter()</code>方法将kiocb、iov_iter3者传入驱动设备的read_iter操作中。</p><p>之前说过，驱动设备预留了文件操作的通用实现。对于文件系统的read_iter来说，不可避免地会用到<code>generic_file_read_iter()</code>。如果kiocb有效且不用等待，就可以在文件的偏移量起始位置进行写回直到结束。</p><p>接下来，read有两个选择，首先判断kiocb的flag是否是Direct IO方式，如果是这个方式则用<code>filemap_write_and_wait_range()</code>确保页是最新的，然后使用<code>mapping-&gt;a_ops-&gt;direct_IO()</code>来访问数据，其中direct_IO是address_space_operations结构里的函数。当遇到iovec读完、遇到EOF、返回错误码、读到DAX文件等情况，此时直接返回。</p><p>如果不是Direct IO方式的时候，调用<code>generic_file_buffered_read()</code>，进行缓存方式的文件读取。这种方式用到了页高速缓存，减少了磁盘的io操作，加快了读写速度。Linux对于内存管理采用了基数树(radix tree)的方法，每个inode有一个address_space对象，结构address_space通过radix树跟踪绑定到地址映射上的核心页。</p><p>在<code>generic_file_buffered_read()</code>中，使用了大量的goto语句来梳理逻辑和处理错误。对于一个正常的流程来说，当读取一个文件时，先要调用<code>find_get_page()</code>，检测数据是否已经缓存，如果没有缓存，则执行预读取<code>page_cache_sync_readahead()</code>、<code>page_cache_async_readahead()</code>从硬盘中读取页。如果内存中没有pagecache，则通过<code>page_cache_alloc_cold()</code>将page加入到<code>add_to_page_cache_lru()</code>，通过LRU算法将数据加载入缓存页。</p><p>在确保找到页缓存且页缓存为最新页后，调用<code>copy_page_to_iter()</code>将内存中的数据拷贝到用户空间，最后用<code>file_accessed()</code>更新文件的最后访问时间。就这样，当击中最新页缓存且iov_iter计数大于0时，拷贝缓存页的数据，当未击中页缓存时，则执行预读取或分配新的缓存页，利用goto语句完成整个迭代器对文件的读取。</p><p><img src="/images/what_we_talk_about_when_we_talk_about_chrdev/chrdev1.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈九号秘事S03.E03中的字谜</title>
      <link href="2019/06/29/Inside_No.9_S03_E03_riddle/"/>
      <url>2019/06/29/Inside_No.9_S03_E03_riddle/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Inside.No.9.S03.E03.the.riddle.of.the.Sphinx<br>斯芬克斯的谜语</p></blockquote><p>开胃菜：</p><p>先来看看这个 What’s long and hard and full of semen？通过谐音双关，semen变换为seamen，谜底也就出来了： submarine。</p><p>如果是这道题呢？</p><p><strong>I TEACH WILD CREATURE WITHOUT HOSPITAL BUILDING – (12)</strong></p><p>12指谜底由12个字母组成。  </p><p>在clue的开头和结尾总是包含两个解谜提示来告诉谜底的含义，其他部分就是wordplay。WILD就是一个anagram-indicator，代表字母可以变换顺序来重新排列（例如upset，excited，insane），所以要去mix up字母。要mix up那些字母呢？</p><p>在这我们就要考虑I TEACH CREATURE，可以发现它重复了两个字母。再看WITHOUT HOSPITAL，HOSPITAL就代表A&amp;E（Accident&amp;Emergency）。它也恰好是上一个句子里重复的两个字母，WITHOUT提示我们要把它删除。删除之后只剩下12个字母，所以要把它重新排列为一个含12个字母的字母变位词。再看最后一个单词BUILDING，将这12个字母重新排列后成为一个指代BUILDING的单词，谜底即为<strong>ARCHITACTURE</strong>。</p><p>留个谜题：What’s pink and hard in the morning？</p><p>主菜：</p><p>来看看正宗的crossword吧。</p><p><img src="/images/Inside_No.9_S03_E03_riddle/empty-crossword.png"></p><p>crossword分为横行across和纵行down。每个开头都有标号，通过给出的提示，来填满所有空格。</p><p>先来看看ACROSS的提示和解法。</p><p><strong>1. To wound and wander destitute (4,3,3)</strong></p><p>TO WOUND AND WANDER作为表示动作的动词或形容词，用来描述destitute的4-3-3词语就是Down-and-out。</p><p><strong>9. Degas evacuated and bathed before putting big picture in bog</strong></p><p>如果要evacuate一些东西，就是指要clean它。所以就把degas的中间部分去掉，只剩DS，bathed也指swam，before提示要把swam放在ds前面。big picture就是指plan，把它put in在swam和ds的中间，就形成了swamplands，也是bog的意思。</p><p><strong>12. I hear American poet solved the riddle of the pseudo-hotel patron</strong></p><p>这个美国诗人是Edgar Guest。riddle solved就是mystery guessed。联系pseudo-hotel patron，谜底就是Mystery guest。</p><p><strong>15. Some smart aleck, no wit, allegedly (4,2,3)</strong></p><p>与know-it-all（贬义）类似。</p><p><strong>18. Tory leader on board for English flower (5)</strong></p><p>Tory的首字母是t，剩下四个字母和T组成一个单词。flower这里双关，代指流体。English表示英国。而board有一个意思是rent，和T就组成了Trent，它是一条英国英格兰中部的河流。</p><p>再看看DOWN的提示和解法：</p><p><strong>1. Indian national product of French-Italian agreement</strong></p><p>关键词是法国的，而又是意大利中一种表示同意(合约和同意双关)的方式(si)，又要和印度相关，所以谜底是desi。</p><p><strong>2. This cover sounds like a 50 Cent song</strong></p><p>考察的是homophone。50 Cent song指代Rap，一个homophone来表示cover又和rap同音，所以谜底为wrap。</p><p><strong>3. A disturbed setter concealed a tiny amount. Why, it’s enough to take one’s breath away.</strong></p><p>setter指代Mr Sphinx，所以就是字母A后面跟着sphinx的anagram。tiny mount在希腊语中是Iota，也是希腊字母表中的第九个字母。why是Y的homophone，也是隐藏的那个tiny amount。要表示take one’s breath away，谜底就是asphyxiation。</p><p><strong>5. Knocked back beer and wine then put on one French undergarment</strong></p><p>Knocked back表示要反写句子。beer的一种是Pils（皮尔森啤酒），wine的一种是Red，反写之后就是slip和der。one在French中是Un。把它们组合在一起就是underslip，和undergarment一个意思。</p><p><strong>7. Catch a train before a poisonous bite</strong></p><p>Catch通常是指抓鱼，a train before指puffer（蒸汽火车），puffer另一个意思是河豚。谜底就是Puffer fish。</p><p><strong>14. Dickens character undertakes to be a cabinet maker</strong></p><p>Dickens指英国作家狄更斯，Oliver Twister是其代表作《雾都孤儿》，Sowerberry是其中人物，也是棺材制造商。</p><p><strong>22. What is a frankfurter’s number-one bun</strong></p><p>frankfurter是指法兰克福香肠，常夹在面包卷中。不以one或bun开头，那就是Neun，它是德语（法兰克福）的数字九。</p><p><strong>23. The origins of a species popularised savage serpents</strong></p><p>Origins提示要使用a species popularised savage里的每个单词第一个字母组成asps，它的意思和serpents一样。</p><p>剧里到最后也没有能够填完crossword，还留下很多空格。不过重看整体，能发现也是隐藏了不少东西的。</p><p><img src="/images/Inside_No.9_S03_E03_riddle/full-crossword.png"><br><strong>I swapped cups</strong></p><p><strong>RIP NHS</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>中国导演电影补全计划(2)</title>
      <link href="2019/04/26/the_road_to_Chinese_director_film_2/"/>
      <url>2019/04/26/the_road_to_Chinese_director_film_2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>正是峰前回雁时</p></blockquote><p>距上一次整理也相隔2个多月了，这次应该是剩下最终的中国导演补片名单了，从第1代导演到第6代导演，从大陆到港台，基本是现阶段对于中国导演领域认知的极限了。接下来应该是注目于亚洲导演了，当然这是后话了。</p><p><strong>王童，张亚璇，王超，王兵，雎安奇，何建军，杨平道，张石川，杨小仲，朱石麟，万古蟾，卜万苍，沈西苓，沈浮，郑君里，崔嵬，桑弧，王苹，凌子风，沈耀庭，吴贻弓，黄蜀芹，吴天明，张暖忻，黄健中，陆小雅，谢飞，滕文骥，郑洞天，米家山，杨亚洲，霍建起，路学长，徐童，周浩，赵亮，李行，白景瑞，陈玉勋，林正盛，易智言，张作骥，胡金铨，方育平，杨凡，张婉婷，严浩。</strong></p><p>（顺序不分先后）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>中国导演电影补全计划(1)</title>
      <link href="2019/02/12/the_road_to_Chinese_director_film_1/"/>
      <url>2019/02/12/the_road_to_Chinese_director_film_1/</url>
      
        <content type="html"><![CDATA[<p>之所以写这篇文章，是因为之前还觉得自己阅片量还可以，但随着对电影这一门艺术的了解越来越深入，愈发觉察自己知之甚少。</p><p>从香港电影到台湾电影，韩国电影到日本电影，苏联电影到美国好莱坞，法国新浪潮到德国表现主义，意大利新现实主义到欧洲先锋电影，乃至巴西的、南美的，甚至说Cult Film、Synth Film、Giallo Film，自己还只停留在表面。</p><p>开启补全计划，一方面为了从自身出发，另一方面为了避免杂乱无章，所以决定从中国导演开始。而在标题后面加个序号，也是为了之后增删改查的便宜。所谓补全，很显然要把该导演的作品看一遍，剔除网络上已找不到的资源之外，大概能把每人的作品看个90%。因此就有必要筛选导演名单。以下所述名单的筛选具有极强的主观意识，属于个人观点。</p><ol><li><p>首先剔除基本只拍烂片的导演，例如毕志飞之流。</p></li><li><p>专注于拍商业片、院线的也去除，一是没那么多时间看这些片子，二是这些之前也看得七七八八了，例如王晶，冯小刚，张艺谋等。</p></li><li><p>偶有好片，但未到精品的也抛弃，例如毕赣，章明，范俭等。</p></li><li><p>能够进入补全名单，但所拍作品基本看完的也不列入，例如李安，忻钰坤，王家卫等。</p></li><li><p>拍过经典，之后随波逐流与市场或者才气不足的也除外，例如陈凯歌，李玉，姜伟，张猛，张黎，管虎，顾长卫，张杨，伍仕贤，李杨等。</p></li><li><p>好片居多，因自己主观而剔除的，例如姜文，宁浩，林超贤，曹保平，陈果等。</p></li></ol><p>剔除名单里，最为可惜的就是第5类导演，在此略过不谈，不再赘述。根据主观的筛选之后，如下的名单就是进入我第一批中国导演补全计划的人(补片顺序不分先后)：</p><p><strong>吴永刚，孙瑜，贾樟柯，费穆，杨德昌，蔡楚生，李睿珺，蔡明亮，娄烨，王小帅，王竞，赵德胤，张元，谢晋，袁牧之，程刚，侯孝贤。</strong></p><blockquote><p>晴天归路好相逐</p></blockquote><p>补片之路漫长，文章掷笔于此，且作一拾遗之处。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>脚尖</title>
      <link href="2018/01/15/toes/"/>
      <url>2018/01/15/toes/</url>
      
        <content type="html"><![CDATA[<p>在脚尖的世界里，他觉得自己一直很孤独。每天大部分时间都被袜子所束缚。</p><p>在外界眼中，袜子是彩色的，煞人眼球。</p><p>而对于自己，袜子等于黑暗。</p><p>袜子给自己的，是透不过气的窒息感，是睁不开眼的无所适从。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>中国文学简史与选读之唐宋词史</title>
      <link href="2016/12/09/the_poem_of_Tang_dynasty_and_the_verse_of_Song_dynasty/"/>
      <url>2016/12/09/the_poem_of_Tang_dynasty_and_the_verse_of_Song_dynasty/</url>
      
        <content type="html"><![CDATA[<p><strong>雨霖铃 · 心请人访</strong></p><p>心请人访。免遭狐假①，涉我烟瘴。<br>所从鹤老龟长②，余花谢了，投闲行傍。<br>相顾春来引步，柳亭雨翻巷。<br>又重续、芳草愁烟，便取河声那堪望。</p><p>相逢祥“阳”醉梦泱，或畋游③、既弃渑水④上。<br>玉液不应兼进，殊不系、更无人唱。<br>宴乐西席，杵臼⑤、倏忽逾情溶漾。<br>重分手、垂钓曾约，去日朱藤杖⑥。</p><p>①：出自《战国策·楚策一》“虎求百兽而食之，得狐。……虎以为然，故遂与之行。兽见之皆走，虎不知兽畏己而走也，以为畏狐也。”。此处代指借取别人声势。<br>②：出自《新荷叶·莲萼飘香》。此处代指时间长。<br>③：出自南朝梁 何逊《七召》：“此武材之矫猛，岂能从我而畋游。” 指畋猎游乐。<br>④：古水名，在山东境内。<br>⑤：出自《后汉书·吴佑传》：“时公沙穆东游太学，无粮，乃变服客佣，为佑凭舂。佑与语，大惊，遂共定交于杵臼之间。“比喻交朋友不计较贫富和身分。<br>⑥：出自唐 白居易《朱藤杖紫骢吟》：“ 江州去日朱藤杖，忠州归时紫骢马。”此处代指旧时光。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一千零一个你</title>
      <link href="2016/10/03/the_most_special_you/"/>
      <url>2016/10/03/the_most_special_you/</url>
      
        <content type="html"><![CDATA[<p>读了一首诗，想起来了你。附和了一首。</p><blockquote><p>我越是逃离<br>却越是靠近你<br>我越是背过脸<br>却越是看见你</p><p>我是一座孤岛<br>处在相思之水中<br>四面八方<br>隔绝我通向你</p><p>一千零一面镜子<br>转映着你的容颜<br>我从你开始<br>我在你结束</p><p>—— 埃姆朗·萨罗希《一千零一面镜子》</p></blockquote><p><strong>一千零一个你</strong></p><p>所以我不再想逃离<br>不再背过脸<br>我只是盯着你<br>就这样盯着你<br>把你整个揉入我</p><p>这样<br>你就不再是一个孤岛<br>不再是一个荒凉的沙漠<br>不再是地上的一滩水<br>匆匆蒸发</p><p>一千零一面镜子<br>转映着你的容颜<br>我从你开始<br>和你一起结束</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>爱和喜欢</title>
      <link href="2016/10/02/love_and_like/"/>
      <url>2016/10/02/love_and_like/</url>
      
        <content type="html"><![CDATA[<p>少用爱这一个字眼，多用用“喜欢”。<br>你真的爱她吗？<br>那么惊天动地的字眼，怎能如此平淡地说出来。<br>但你是非常非常，非常非常喜欢她。<br>喜欢她什么呢？<br>可能你也不是很清楚。<br>可是你就是觉得自己很喜欢她。<br>你自动过滤了爱这个字眼。<br>为什么呢？<br>因为，<br>你那样喜欢她。</p><p>你会觉得她身上每个地方都是香的。<br>洗澡后的头发是香的，跑完步的汗味是香的，夏天上课时坐在她后面，看见他的脖颈，也是香的。</p><p>你会觉得她身上每个地方都如此精雕细琢。<br>那鼻梁，那脸颊，那不加修饰的眼睛，那么诱人的身材，长裙下露出的小腿，高跟鞋中的脚背，不经意时的锁骨，双手叉腰的时候，昂头撅嘴的时候。如此可人。</p><p>你会觉得无论她在干什么，都是风姿绰绰，百媚千娇</p><p>喜欢一个人的时候，<br>比爱一个人的时候，<br>更敏感。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>你踮起脚尖</title>
      <link href="2016/10/01/you_tips_toes/"/>
      <url>2016/10/01/you_tips_toes/</url>
      
        <content type="html"><![CDATA[<p>我站在车水马龙之间，除了你的背影，一无所有。<br>你左右脚轮番轻轻踮起脚尖，向着前方迈去。<br>路人眼中，你是雀跃的。<br>可在我的眼里，你就如同宣纸上泛开的墨汁，聚不拢，收不回。<br>你呢，蹦蹦跳跳时又是怎样一副心情？<br>阳光很稀薄，你的背影，却拉长到了我的脚尖。<br>它压在上面，我抬不起脚来。<br>你忽然回头了。<br>不是回眸一笑，我看不清你的表情。<br>你就在稀薄的阳光中，向我冲了过来。<br>你把我拥入怀中。瘦小的你，就这样把我抱住，紧的不可思议。<br>你馥郁的头发把我围绕，勒紧着我的脖子，让我就此窒息在你的怀抱里。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
