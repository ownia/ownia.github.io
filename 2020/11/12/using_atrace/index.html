<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="ATrace是什么ATarce(Android system and app trace events)是Android系统和软件的事件追踪器，支持用户空间的系统事件和软件事件，以及内核空间的函数追踪。它支持设置属性来进行用户空间追踪，也可以写入ftrace的sysfs节点进行事件追踪，还能利用function tracer进行内核中大部分函数进行追踪。 它一方面通过NDK层设置接口给JNI提供A">
<meta property="og:type" content="article">
<meta property="og:title" content="Using ATrace(Android system and app trace events)">
<meta property="og:url" content="http://ownia.top/2020/11/12/using_atrace/index.html">
<meta property="og:site_name" content="Ownia">
<meta property="og:description" content="ATrace是什么ATarce(Android system and app trace events)是Android系统和软件的事件追踪器，支持用户空间的系统事件和软件事件，以及内核空间的函数追踪。它支持设置属性来进行用户空间追踪，也可以写入ftrace的sysfs节点进行事件追踪，还能利用function tracer进行内核中大部分函数进行追踪。 它一方面通过NDK层设置接口给JNI提供A">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://ownia.top/images/using_atrace/atrace_2.jpg">
<meta property="og:image" content="http://ownia.top/images/using_atrace/zygote.jpg">
<meta property="og:image" content="http://ownia.top/images/using_atrace/getprop.jpg">
<meta property="og:image" content="http://ownia.top/images/using_atrace/atrace_call.jpg">
<meta property="og:image" content="http://ownia.top/images/using_atrace/jniatrace.png">
<meta property="og:image" content="http://ownia.top/images/using_atrace/tracetag.jpg">
<meta property="og:image" content="http://ownia.top/images/using_atrace/framework.png">
<meta property="og:image" content="http://ownia.top/images/using_atrace/appname.jpg">
<meta property="og:image" content="http://ownia.top/images/using_atrace/compare.png">
<meta property="article:published_time" content="2020-11-12T00:00:00.000Z">
<meta property="article:modified_time" content="2021-03-15T14:37:39.745Z">
<meta property="article:author" content="Ownia">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ownia.top/images/using_atrace/atrace_2.jpg">
    
    
    <!-- title -->
    <title>Using ATrace(Android system and app trace events)</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Using ATrace(Android system and app trace events)
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Ownia</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-11-12T00:00:00.000Z" itemprop="datePublished">2020-11-12</time>
        
      
    </div>


      

      

    </div>
  </header>
  <div class="content" itemprop="articleBody">
    <h2 id="ATrace是什么"><a href="#ATrace是什么" class="headerlink" title="ATrace是什么"></a>ATrace是什么</h2><p>ATarce(Android system and app trace events)是Android系统和软件的事件追踪器，支持用户空间的系统事件和软件事件，以及内核空间的函数追踪。它支持设置属性来进行用户空间追踪，也可以写入ftrace的sysfs节点进行事件追踪，还能利用function tracer进行内核中大部分函数进行追踪。</p>
<p>它一方面通过NDK层设置接口给JNI提供API，另一方面又通过zygote在Android内部进程中对属性及时响应，还在通过设置ftrace下的节点属性控制信息输出。</p>
<h2 id="ATrace流程图"><a href="#ATrace流程图" class="headerlink" title="ATrace流程图"></a>ATrace流程图</h2><p><img src="/images/using_atrace/atrace_2.jpg" alt="atrace_2"></p>
<h2 id="ATrace信息捕获"><a href="#ATrace信息捕获" class="headerlink" title="ATrace信息捕获"></a>ATrace信息捕获</h2><p>根据atrace.cpp源码可以看出，对于追踪类型的分类依据来源于k_categories结构中定义好的值。k_categories是一个TracingCategory结构体，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct TracingCategory &#123;</span><br><span class="line">    &#x2F;&#x2F; The name identifying the category.</span><br><span class="line">    const char* name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; A longer description of the category.</span><br><span class="line">    const char* longname;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The userland tracing tags that the category enables.</span><br><span class="line">    uint64_t tags;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The fname&#x3D;&#x3D;NULL terminated list of &#x2F;sys&#x2F; files that the category</span><br><span class="line">    &#x2F;&#x2F; enables.</span><br><span class="line">    struct &#123;</span><br><span class="line">        &#x2F;&#x2F; Whether the file must be writable in order to enable the tracing</span><br><span class="line">        &#x2F;&#x2F; category.</span><br><span class="line">        requiredness required;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; The path to the enable file.</span><br><span class="line">        const char* path;</span><br><span class="line">    &#125; sysfiles[MAX_SYS_FILES];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中成员tags能够对用户空间的追踪选项进行标识，sysfiles则提供了某个追踪类别的节点信息。atrace使用参数-k来标识是否启用内核函数追踪。根据参数-k和k_categories可以知道，atrace主要采用如下几种方式来进行追踪。</p>
<h4 id="1-ATRACE-TAG方式"><a href="#1-ATRACE-TAG方式" class="headerlink" title="1. ATRACE_TAG方式"></a>1. ATRACE_TAG方式</h4><p>ATRACE_TAG方式是atrace的默认方式，使能方法是传入默认的追踪类型。它是只针对用户空间的追踪方式，通过将k_categories中各个非零tags的标识位进行按位或运算后来设置系统属性debug.atrace.tags.enableflags。在Android系统中，zygote进程启动后，通过一系列调用判断ATRACE_TAG的设置和ATRACE_CALL()或ATrace_beginSection的位置，以WRITE_MSG的形式写入atrace_marker_fd，即trace_marker的位置，填充ftrace的ring buffer。具体的时序图如下:</p>
<p><img src="/images/using_atrace/zygote.jpg" alt="zygote"></p>
<p><img src="/images/using_atrace/getprop.jpg" alt="getprop"></p>
<p><img src="/images/using_atrace/atrace_call.jpg" alt="atrace_call"></p>
<p>在NDK层封装好API后，通过JNI的机制，就可以在java里调用trace。在<code>frameworks/base/core/jni/android_os_Trace.cpp</code>中设置如下:</p>
<p><img src="/images/using_atrace/jniatrace.png" alt="jniatrace"></p>
<p>对于ATRACE_TAG来说，java层采取和libcutils相同的方式，采用相同的标志位进行声明，确保分类一致。</p>
<p><img src="/images/using_atrace/tracetag.jpg" alt="tracetag"></p>
<p>之后就可以在framework层中轻松的使用trace了，例如:</p>
<p><img src="/images/using_atrace/framework.png" alt="framework"></p>
<h4 id="2-appname方式"><a href="#2-appname方式" class="headerlink" title="2. appname方式"></a>2. appname方式</h4><p>appname方式能够对设置的进程名称进行追踪，但可能会导致一系列不可控的返回信息。其使能方式是通过参数-a传入包名来进行设置，然后设置系统属性debug.atrace.app_number和debug.atrace.app，确定追踪的包名的个数和对应的属性，之后也是类似ATRACE_TAG的方式使用libcutils进行追踪。具体的时序图如下：</p>
<p><img src="/images/using_atrace/appname.jpg" alt="appname"></p>
<p>appname方式会在进程内部读取/proc/self/cmdline的第一行，然后和系统属性debug.atrace.app进行比对，当匹配成功时代表该进程需要进行app级别的调试追踪，然后设置ATRACE_TAG_APP，</p>
<h4 id="3-trace-event方式"><a href="#3-trace-event方式" class="headerlink" title="3. trace event方式"></a>3. trace event方式</h4><p>trace event方式是对debugfs中events下的节点使能来进行追踪控制的。通常来说，trace event使用宏TRACE_EVENT()来新增追踪事件。当对应节点被使能后，函数插桩被激活，桩点中的函数被调用时就会被记录下来，将数据通过设置好的filter和trigger存储到ring buffer中，最后通过设置好的format进行格式化输出。</p>
<p>对于format中每个块来说，filed格式为<code>field:field-type field-name; offset:N; size:N;</code>，如果一个field-name以<code>common_</code>开头的话，说明这个field是公共定义的，在相同的event下都享受这个filed。</p>
<p>对于event的filter来说，可以通过多种方式就行过滤。比如可以通过表达式语法来指定某些条件下field-name的匹配；也可以直接控制某个event下的所有子系统，此时会根据具体的filter下是否有修改的field来进行修改；还可以利用PID的方式直接对<code>set_event_pid</code>节点进行设置。</p>
<p>trigger则是用来对event的控制命令进行过滤。它可以控制这个另一个event的开启与关闭当这个event的trigger被激活时，也可以转储堆栈追踪、记录捕获的函数到snapshot中，也能直接控制追踪的开启与关闭。值得注意的是，这些trigger commands都能通过表达式语法来进行更细致的控制，能够直接对每个event定义的<code>TP_STRUCT__entry</code>中的成员来用于条件判断。</p>
<h4 id="4-内核函数追踪方式"><a href="#4-内核函数追踪方式" class="headerlink" title="4. 内核函数追踪方式"></a>4. 内核函数追踪方式</h4><p>内核函数追踪方式能够对内核中大部分函数(不包括notrace、inline、某些特殊函数)进行追踪，其原理是ftrace中的dynamic fucntion tracer。内核函数追踪的使能方式是通过参数-k来设置要追踪哪几个函数。dynamic fucntion tracer有两种方式，一种是function的方式，另一种是function_graph的方式。对于dynamic fucntion tracer来说，它可以把不需要追踪的函数入口处指令<code>bl _mcount</code>替换成<code>nop</code>，这样基本对性能无影响，对需要追踪的函数替换入口处指令<code>bl _mcount</code>替换为<code>ftrace_caller</code>。对于dynamic function_graph tracer来说，则需要对函数的入口和出口同时插桩，获得函数的执行时间。需要注意的是，atrace默认的内核函数采用function_graph的方式进行，而修改后的atrace则可以采用function的方式。</p>
<h2 id="function与function-graph的性能比较"><a href="#function与function-graph的性能比较" class="headerlink" title="function与function_graph的性能比较"></a>function与function_graph的性能比较</h2><p><img src="/images/using_atrace/compare.png" alt="compare"></p>
<p>根据实际测试比较可知，在使用function和function_graph两种tracer时候，在其他参数一致的情况下，两种方式的追踪消耗时间实际上是差不多的，而且内存占用也差不多。但是function tracer比function_graph tracer的cpu消耗多了40%，而且与系统追踪相比，内核追踪的cpu消耗极大。</p>

  </div>
</article>

        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ATrace%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">ATrace是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ATrace%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">2.</span> <span class="toc-text">ATrace流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ATrace%E4%BF%A1%E6%81%AF%E6%8D%95%E8%8E%B7"><span class="toc-number">3.</span> <span class="toc-text">ATrace信息捕获</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ATRACE-TAG%E6%96%B9%E5%BC%8F"><span class="toc-number">3.0.1.</span> <span class="toc-text">1. ATRACE_TAG方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-appname%E6%96%B9%E5%BC%8F"><span class="toc-number">3.0.2.</span> <span class="toc-text">2. appname方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-trace-event%E6%96%B9%E5%BC%8F"><span class="toc-number">3.0.3.</span> <span class="toc-text">3. trace event方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E8%BF%BD%E8%B8%AA%E6%96%B9%E5%BC%8F"><span class="toc-number">3.0.4.</span> <span class="toc-text">4. 内核函数追踪方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#function%E4%B8%8Efunction-graph%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-number">4.</span> <span class="toc-text">function与function_graph的性能比较</span></a></li></ol>
    </div>


  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021
    Ownia
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
