<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="MineSweeper的实现思路 使用二维的vector容器数组存储gameMap 使用结构体MineBlock存储gameMap信息 使用枚举法判断周围的地雷数量 使用递归法进行挖雷 计算周围地雷数量时要排除本身 标记分为错误标记(MARKED)和正确标记(WRONG_MARK)，需要对两个标记进行区分(在ui层游戏结束时做绘制区分) 一个方块如果标记两次会回到UNDIG的状态  在构造函数里面">
<meta property="og:type" content="article">
<meta property="og:title" content="扫雷MineSweeper的设计">
<meta property="og:url" content="http://ownia.top/2018/03/05/MineSweeperDesign/index.html">
<meta property="og:site_name" content="Ownia">
<meta property="og:description" content="MineSweeper的实现思路 使用二维的vector容器数组存储gameMap 使用结构体MineBlock存储gameMap信息 使用枚举法判断周围的地雷数量 使用递归法进行挖雷 计算周围地雷数量时要排除本身 标记分为错误标记(MARKED)和正确标记(WRONG_MARK)，需要对两个标记进行区分(在ui层游戏结束时做绘制区分) 一个方块如果标记两次会回到UNDIG的状态  在构造函数里面">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-03-05T00:00:00.000Z">
<meta property="article:modified_time" content="2021-03-15T14:37:39.742Z">
<meta property="article:author" content="Ownia">
<meta name="twitter:card" content="summary">
    
    
    <!-- title -->
    <title>扫雷MineSweeper的设计</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        扫雷MineSweeper的设计
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Ownia</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2018-03-05T00:00:00.000Z" itemprop="datePublished">2018-03-05</time>
        
      
    </div>


      

      

    </div>
  </header>
  <div class="content" itemprop="articleBody">
    <h4 id="MineSweeper的实现思路"><a href="#MineSweeper的实现思路" class="headerlink" title="MineSweeper的实现思路"></a>MineSweeper的实现思路</h4><ul>
<li>使用二维的vector容器数组存储gameMap</li>
<li>使用结构体MineBlock存储gameMap信息</li>
<li>使用枚举法判断周围的地雷数量</li>
<li>使用递归法进行挖雷</li>
<li>计算周围地雷数量时要排除本身</li>
<li>标记分为错误标记(MARKED)和正确标记(WRONG_MARK)，需要对两个标记进行区分(在ui层游戏结束时做绘制区分)</li>
<li>一个方块如果标记两次会回到UNDIG的状态</li>
</ul>
<p>在构造函数里面不做具体初始化，因为构造函数的调用时间不确定<br>界面设置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blockSize = <span class="number">20</span>; <span class="comment">//方块大小</span></span><br><span class="line">offsetX = <span class="number">5</span>; <span class="comment">//横向边距</span></span><br><span class="line">offsetY = <span class="number">5</span>; <span class="comment">//纵向边距</span></span><br><span class="line">scroeboardY = <span class="number">70</span>; <span class="comment">//记分板高度</span></span><br></pre></td></tr></table></figure>
<p>设置窗口控件固定大小 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">game -&gt; mCol * blockSize + offsetX * 2</span><br><span class="line">game -&gt; mRow * blockSize + offsetY * 2 + scroeboardY</span><br><span class="line">(game -&gt; mCol) * 20 + 5 * 2</span><br><span class="line">(game -&gt; mRow) * 20 + 5 * 2 + 70</span><br></pre></td></tr></table></figure>
<p>drawPixmap()使用GPU处理，相对减轻了CPU的负担</p>
<p><code>void QPainter::drawPixmap(int x, int y, const QPixmap &amp; pixmap, int sx = 0, int sy = 0, int sw = -1, int sh = -1)</code><br>通过把pixmap的一部分复制到绘制设备中，在(x, y)绘制一个像素映射。<br>(x, y)指定了要被绘制的绘制设备的左上点<br>(sx, sy)指定了要被绘制的pixmap中的左上点，默认为(0, 0)。<br>(sw, sh)指定了要被绘制的pixmap的大小，默认(-1, -1)，意思是一直到像素映射的右下。<br>当在QPrinter上绘制时，当前像素映射的遮蔽或者它的alpha通道被忽略。</p>
<p>游戏的四种状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case OVER:</span><br><span class="line">painter.drawPixmap((game -&gt; mCol * blockSize + offsetX * 2) &#x2F; 2 - 12, scroeboardY &#x2F; 2 + 3.5, bmpFaces, 0 * 24, 0, 24, 24);</span><br><span class="line">break;</span><br><span class="line">case PLAYING:</span><br><span class="line">painter.drawPixmap((game -&gt; mCol * blockSize + offsetX * 2) &#x2F; 2 - 12, scroeboardY &#x2F; 2+ 3.5, bmpFaces, 1 * 24, 0, 24, 24);</span><br><span class="line">break;</span><br><span class="line">case WIN:</span><br><span class="line">painter.drawPixmap((game -&gt; mCol * blockSize + offsetX * 2) &#x2F; 2 - 12, scroeboardY &#x2F; 2+ 3.5, bmpFaces, 2 * 24, 0, 24, 24);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">painter.drawPixmap((game -&gt; mCol * blockSize + offsetX * 2) &#x2F; 2 - 12, scroeboardY &#x2F; 2+ 3.5, bmpFaces, 1 * 24, 0, 24, 24);</span><br><span class="line">break;</span><br></pre></td></tr></table></figure>
<p><code>((game -&gt; mCol) * 20 + 5 * 2))/2 -12</code>先取控件宽度中心，再减去图像大小24的一半12，获得x轴位置<br><code>70 / 2 + 3.5 = 38.5</code>取记分板高度70的一半加3.5，获得y轴位置<br><code>0 * 24</code>第一个图形的sx值<br><code>1 * 24</code>第二个图形的sx值<br><code>2 * 24</code>第三个图形的sx值<br>三个图形的sy值都为0<br>要绘制的pixmap大小即为24</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = game -&gt; currentMineNumber;</span><br><span class="line"><span class="keyword">int</span> posX = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	painter.drawPixmap(posX, scroeboardY / <span class="number">2</span> + <span class="number">1.5</span>, bmpTimeNumber, n * <span class="number">20</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">28</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	painter.drawPixmap(posX - <span class="number">20</span>, scroeboardY / <span class="number">2</span> + <span class="number">1.5</span>, bmpTimeNumber, 	n % <span class="number">10</span> * <span class="number">20</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">28</span>); <span class="comment">//每次从后面绘制一位</span></span><br><span class="line">	n /= <span class="number">10</span>;</span><br><span class="line">	posX -= <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>posX = 50</code>获得x轴位置<br><code>70 / 2 + 1.5 = 36.5</code>取记分板高度70的一半加1.5，获得y轴位置<br><code>n % 10 * 20</code>先取最后一位数字<br><code>n /= 10, posX -= 20</code>向前移一位，取得第一位数字</p>
<p>currentState的状态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(game -&gt; gameMap[i][j].currentState)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">case</span> UNDIG:</span><br><span class="line">		painter.drawPixmap(j * blockSize + offsetX, i * blockSize + offsetY + scroeboardY , bmpBlocks, blockSize * <span class="number">10</span>, <span class="number">0</span>, blockSize, blockSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DIGGED:</span><br><span class="line">		painter.drawPixmap(j * blockSize + offsetX, i * blockSize + offsetY + scroeboardY, bmpBlocks, blockSize * game -&gt; gameMap[i][j].valueFlag, <span class="number">0</span>, blockSize, blockSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MARKED:</span><br><span class="line">		painter.drawPixmap(j * blockSize + offsetX, i * blockSize + offsetY + scroeboardY, bmpBlocks, blockSize * <span class="number">11</span>, <span class="number">0</span>, blockSize, blockSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BOMB:</span><br><span class="line">		painter.drawPixmap(j * blockSize + offsetX, i * blockSize + offsetY + scroeboardY, bmpBlocks, blockSize * <span class="number">9</span>, <span class="number">0</span>, blockSize, blockSize);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WRONG_MARK:</span><br><span class="line">		<span class="keyword">if</span>(game-&gt;gameState == PLAYING || game-&gt;gameState == FAULT)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果还在游戏中就显示旗子</span></span><br><span class="line">			painter.drawPixmap(j * blockSize + offsetX, i * blockSize + offsetY + scroeboardY, bmpBlocks, blockSize * <span class="number">11</span>, <span class="number">0</span>, blockSize, blockSize);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(game-&gt;gameState == OVER)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果游戏已经结束，就显示标错了</span></span><br><span class="line">			painter.drawPixmap(j * blockSize + offsetX, i * blockSize + offsetY + scroeboardY, bmpBlocks, blockSize * <span class="number">12</span>, <span class="number">0</span>, blockSize, blockSize);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>game -&gt; gameMap[i][j].currentState</code>获得该方块的状态<br><code>j * 20 + 5</code>获得x轴位置<br><code>i * 20 + 5 + 70</code>获得y轴位置<br>根据状态UNDIG，DIGGED，MARKED，BOMB，WRONG_MARK分别绘制相应图像<br>其中比较特殊的是DIGGED和WRONG_MARK</p>
<p>DIGGED的pixmap的sx选取是通过<code>20 * game -&gt; gameMap[i][j].valueFlag</code>来选取<br>WRONG_MARK的对应绘制图像是要先判断游戏是否结束，然后分别显示不同的图像</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &gt;= (game -&gt; mCol * blockSize + offsetX * <span class="number">2</span>) / <span class="number">2</span> - <span class="number">12</span> &amp;&amp; x &lt;= (game -&gt; mCol * blockSize + offsetX * <span class="number">2</span>) / <span class="number">2</span> + <span class="number">12</span> &amp;&amp; y &gt;= scroeboardY / <span class="number">2</span> + <span class="number">3.5</span> &amp;&amp; y &lt;= scroeboardY / <span class="number">2</span> + <span class="number">3.5</span> + <span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<p>判断鼠标指针是否点击了faces图案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &gt;= (game -&gt; mCol * <span class="number">20</span> + <span class="number">5</span> * <span class="number">2</span>) / <span class="number">2</span> - <span class="number">12</span> &amp;&amp; x &lt;= (game -&gt; mCol * <span class="number">20</span> + <span class="number">5</span> * <span class="number">2</span>) / <span class="number">2</span> + <span class="number">12</span> &amp;&amp; y &gt;= <span class="number">70</span> / <span class="number">2</span> + <span class="number">3.5</span> &amp;&amp; y &lt;= <span class="number">70</span> / <span class="number">2</span> + <span class="number">3.5</span> + <span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<p>计算得出鼠标所点击的block的row值和col值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> px = event-&gt;x() - offsetX;</span><br><span class="line"><span class="keyword">int</span> py = event-&gt;y() - offsetY - scroeboardY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row = py / blockSize;</span><br><span class="line"><span class="keyword">int</span> col = px / blockSize;</span><br></pre></td></tr></table></figure>

  </div>
</article>

        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#MineSweeper%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">1.</span> <span class="toc-text">MineSweeper的实现思路</span></a></li></ol>
    </div>


  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021
    Ownia
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
